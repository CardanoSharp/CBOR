<docs>
  <doc name='T:PeterO.ArrayWriter'>
    <summary>An array of bytes that grows as needed.
    </summary>
  </doc>
  <doc name='M:PeterO.ArrayWriter.#ctor'>
    <summary>Initializes a new instance of the
      <see cref='ArrayWriter'/>
       class with a default buffer size.
    </summary>
  </doc>
  <doc name='M:PeterO.ArrayWriter.#ctor(System.Int32)'>
    <summary>Initializes a new instance of the
      <see cref='ArrayWriter'/>
       class with the given initial buffer size.
    </summary>
    <param name='initialSize'>The parameter
      <paramref name='initialSize'/>
       is a 32-bit signed integer.
    </param>
  </doc>
  <doc name='M:PeterO.ArrayWriter.Clear'>
    <summary>Offers a fast way to reset the length of the array writer's data to 0.
    </summary>
  </doc>
  <doc name='M:PeterO.ArrayWriter.ToArray'>
    <summary>Generates an array of all bytes written so far to it.
    </summary>
    <returns>A byte array.
    </returns>
  </doc>
  <doc name='M:PeterO.ArrayWriter.Write(System.Byte[],System.Int32,System.Int32)'>
    <summary>Writes a series of bytes to the array.
    </summary>
    <param name='src'>Byte array containing the data to write.
    </param>
    <param name='offset'>A zero-based index showing where the desired portion of
      <paramref name='src'/>
       begins.
    </param>
    <param name='length'>The number of elements in the desired portion of
      <paramref name='src'/>
       (but not more than
      <paramref name='src'/>
       's length).
    </param>
    <exception cref='T:System.ArgumentNullException'>The parameter
      <paramref name='src'/>
       is null.
    </exception>
    <exception cref='T:System.ArgumentException'>Either
      <paramref name='offset'/>
       or
      <paramref name='length'/>
       is less than 0 or greater than
      <paramref name='src'/>
       's length, or
      <paramref name='src'/>
       ' s length minus
      <paramref name='offset'/>
       is less than
      <paramref name='length'/>
       .
    </exception>
  </doc>
  <doc name='M:PeterO.ArrayWriter.WriteByte(System.Int32)'>
    <summary>Writes an 8-bit byte to the array.
    </summary>
    <param name='byteValue'>An integer containing the byte to write. Only the lower 8 bits of this
      value will be used.
    </param>
  </doc>
  <doc name='T:PeterO.Cbor.CBORDataUtilities'>
    <summary>Contains methods useful for reading and writing data, with a focus on
      CBOR.
    </summary>
  </doc>
  <doc name='M:PeterO.Cbor.CBORDataUtilities.ParseJSONNumber(System.String)'>
    <summary>Parses a number whose format follows the JSON specification. See
      #ParseJSONNumber(String, integersOnly, parseOnly) for more information.
    </summary>
    <param name='str'>A string to parse. The string is not allowed to contain white space
      characters, including spaces.
    </param>
    <returns>A CBOR object that represents the parsed number. Returns positive zero if
      the number is a zero that starts with a minus sign (such as "-0" or
      "-0.0"). Returns null if the parsing fails, including if the string is
      null or empty.
    </returns>
  </doc>
  <doc name='M:PeterO.Cbor.CBORDataUtilities.ParseJSONNumber(System.String,System.Boolean,System.Boolean)'>
    <summary>Parses a number whose format follows the JSON specification (RFC 8259).
      Roughly speaking, a valid number consists of an optional minus sign, one
      or more basic digits (starting with 1 to 9 unless the only digit is 0), an
      optional decimal point (".", full stop) with one or more basic digits, and
      an optional letter E or e with an optional plus or minus sign and one or
      more basic digits (the exponent).
    </summary>
    <param name='str'>A string to parse. The string is not allowed to contain white space
      characters, including spaces.
    </param>
    <param name='integersOnly'>If true, no decimal points or exponents are allowed in the string.
    </param>
    <param name='positiveOnly'>If true, only positive numbers are allowed (the leading minus is
      disallowed).
    </param>
    <returns>A CBOR object that represents the parsed number. Returns positive zero if
      the number is a zero that starts with a minus sign (such as "-0" or
      "-0.0"). Returns null if the parsing fails, including if the string is
      null or empty.
    </returns>
  </doc>
  <doc name='M:PeterO.Cbor.CBORDataUtilities.ParseJSONNumber(System.String,System.Boolean,System.Boolean,System.Boolean)'>
    <summary>Parses a number whose format follows the JSON specification (RFC 8259).
      Roughly speaking, a valid number consists of an optional minus sign, one
      or more basic digits (starting with 1 to 9 unless the only digit is 0), an
      optional decimal point (".", full stop) with one or more basic digits, and
      an optional letter E or e with an optional plus or minus sign and one or
      more basic digits (the exponent).
    </summary>
    <param name='str'>A string to parse. The string is not allowed to contain white space
      characters, including spaces.
    </param>
    <param name='integersOnly'>If true, no decimal points or exponents are allowed in the string.
    </param>
    <param name='positiveOnly'>If true, only positive numbers are allowed (the leading minus is
      disallowed).
    </param>
    <param name='preserveNegativeZero'>If true, returns positive zero if the number is a zero that starts with a
      minus sign (such as "-0" or "-0.0"). Otherwise, returns negative zero in
      this case.
    </param>
    <returns>A CBOR object that represents the parsed number. Returns null if the
      parsing fails, including if the string is null or empty.
    </returns>
  </doc>
  <doc name='T:PeterO.Cbor.CBOREncodeOptions'>
    <summary>Specifies options for encoding and decoding CBOR objects.
    </summary>
  </doc>
  <doc name='M:PeterO.Cbor.CBOREncodeOptions.#ctor'>
    <summary>Initializes a new instance of the
      <see cref='CBOREncodeOptions'/>
       class.
    </summary>
  </doc>
  <doc name='M:PeterO.Cbor.CBOREncodeOptions.#ctor(System.Boolean,System.Boolean)'>
    <summary>Initializes a new instance of the
      <see cref='CBOREncodeOptions'/>
       class.
    </summary>
    <param name='useIndefLengthStrings'>A value indicating whether to always encode strings with a definite-length
      encoding.
    </param>
    <param name='allowDuplicateKeys'>A value indicating whether to disallow duplicate keys when reading CBOR
      objects from a data stream.
    </param>
  </doc>
  <doc name='M:PeterO.Cbor.CBOREncodeOptions.#ctor(System.Boolean,System.Boolean,System.Boolean)'>
    <summary>Initializes a new instance of the
      <see cref='CBOREncodeOptions'/>
       class.
    </summary>
    <param name='useIndefLengthStrings'>A value indicating whether to encode strings with a definite-length
      encoding in certain cases.
    </param>
    <param name='allowDuplicateKeys'>A value indicating whether to allow duplicate keys when reading CBOR
      objects from a data stream.
    </param>
    <param name='ctap2Canonical'>A value indicating whether CBOR objects are written out using the CTAP2
      canonical CBOR encoding form, which is useful for implementing Web
      Authentication.
    </param>
  </doc>
  <doc name='P:PeterO.Cbor.CBOREncodeOptions.AllowDuplicateKeys'>
    <summary>Gets a value indicating whether to allow duplicate keys when reading CBOR
      objects from a data stream. Used only when decoding CBOR objects.
    </summary>
    <value>A value indicating whether to allow duplicate keys when reading CBOR
      objects from a data stream. The default is false.
    </value>
  </doc>
  <doc name='M:PeterO.Cbor.CBOREncodeOptions.And(PeterO.Cbor.CBOREncodeOptions)'>
    <summary>Returns an options object containing the flags shared by this and another
      options object.
    </summary>
    <param name='o'>The parameter
      <paramref name='o'/>
       is a CBOREncodeOptions object.
    </param>
    <returns>A CBOREncodeOptions object.
    </returns>
  </doc>
  <doc name='P:PeterO.Cbor.CBOREncodeOptions.Ctap2Canonical'>
    <summary>Gets a value indicating whether CBOR objects are written out using the
      CTAP2 canonical CBOR encoding form, which is useful for implementing Web
      Authentication. In this form, CBOR tags are not used, map keys are written
      out in a canonical order, and non-integer numbers and integers 2^63 or
      greater are written as 64-bit binary floating-point numbers.
    </summary>
    <value><c>true</c> if CBOR objects are written out using the CTAP2 canonical CBOR encoding
      form; otherwise,
      <c>false</c> .
    </value>
  </doc>
  <doc name='F:PeterO.Cbor.CBOREncodeOptions.Default'>
    <summary>Default options for CBOR objects. Disallow duplicate keys, and always
      encode strings using definite-length encoding.
    </summary>
  </doc>
  <doc name='F:PeterO.Cbor.CBOREncodeOptions.DefaultCtap2Canonical'>
    <summary>Default options for CBOR objects serialized using the CTAP2
      canonicalization (used in Web Authentication, among other specifications).
      Disallow duplicate keys, and always encode strings using definite-length
      encoding.
    </summary>
  </doc>
  <doc name='F:PeterO.Cbor.CBOREncodeOptions.NoDuplicateKeys'>
    <summary>Disallow duplicate keys when reading CBOR objects from a data stream. Used
      only when decoding CBOR objects. Value: 2.
    </summary>
  </doc>
  <doc name='F:PeterO.Cbor.CBOREncodeOptions.NoIndefLengthStrings'>
    <summary>Always encode strings with a definite-length encoding. Used only when
      encoding CBOR objects. Value: 1.
    </summary>
  </doc>
  <doc name='F:PeterO.Cbor.CBOREncodeOptions.None'>
    <summary>No special options for encoding/decoding. Value: 0.
    </summary>
  </doc>
  <doc name='M:PeterO.Cbor.CBOREncodeOptions.Or(PeterO.Cbor.CBOREncodeOptions)'>
    <summary>Returns an options object containing the combined flags of this and
      another options object.
    </summary>
    <param name='o'>The parameter
      <paramref name='o'/>
       is a CBOREncodeOptions object.
    </param>
    <returns>A new CBOREncodeOptions object.
    </returns>
  </doc>
  <doc name='P:PeterO.Cbor.CBOREncodeOptions.UseIndefLengthStrings'>
    <summary>Gets a value indicating whether to encode strings with an
      indefinite-length encoding under certain circumstances.
    </summary>
    <value>A value indicating whether to encode strings with an indefinite-length
      encoding under certain circumstances. The default is false.
    </value>
  </doc>
  <doc name='P:PeterO.Cbor.CBOREncodeOptions.Value'>
    <summary>Gets this options object's value.
    </summary>
    <value>This options object&apos;s value.
    </value>
  </doc>
  <doc name='T:PeterO.Cbor.CBORException'>
    <summary>Exception thrown for errors involving CBOR data.
    </summary>
  </doc>
  <doc name='M:PeterO.Cbor.CBORException.#ctor'>
    <summary>Initializes a new instance of the
      <see cref='CBORException'/>
       class.
    </summary>
  </doc>
  <doc name='M:PeterO.Cbor.CBORException.#ctor(System.String)'>
    <summary>Initializes a new instance of the
      <see cref='CBORException'/>
       class.
    </summary>
    <param name='message'>The parameter
      <paramref name='message'/>
       is a text string.
    </param>
  </doc>
  <doc name='M:PeterO.Cbor.CBORException.#ctor(System.String,System.Exception)'>
    <summary>Initializes a new instance of the
      <see cref='CBORException'/>
       class. Uses the given message and inner exception.
    </summary>
    <param name='message'>The parameter
      <paramref name='message'/>
       is a text string.
    </param>
    <param name='innerException'>The parameter
      <paramref name='innerException'/>
       is an Exception object.
    </param>
  </doc>
  <doc name='T:PeterO.Cbor.CBORObject'>
    <summary><para>Represents an object in Concise Binary Object Representation (CBOR) and
        contains methods for reading and writing CBOR data. CBOR is defined in
        RFC 7049.
      </para>
    </summary>
    <remarks>
      <para><b>Converting CBOR objects</b> </para>
      <para>There are many ways to get a CBOR object, including from bytes, objects,
        streams and JSON, as described below.
      </para>
      <para><b>To and from byte arrays:</b> The CBORObject.DecodeFromBytes method converts a byte array in CBOR
        format to a CBOR object. The EncodeToBytes method converts a CBOR object
        to its corresponding byte array in CBOR format.
      </para>
      <para><b>To and from data streams:</b> The CBORObject.Write methods write many kinds of objects to a data
        stream, including numbers, CBOR objects, strings, and arrays of numbers
        and strings. The CBORObject.Read method reads a CBOR object from a data
        stream.
      </para>
      <para><b>To and from other objects:</b> The
        <c>CBORObject.FromObject</c> method converts many kinds of objects to a CBOR object, including
        numbers, strings, and arrays and maps of numbers and strings. Methods
        like AsDouble, AsByte, and AsString convert a CBOR object to different
        types of object. The
        <c>CBORObject.ToObject</c> method converts a CBOR object to an object of a given type; for
        example, a CBOR array to a native
        <c>List</c> (or
        <c>ArrayList</c> in Java), or a CBOR integer to an
        <c>int</c> or
        <c>long</c> .
      </para>
      <para><b>To and from JSON:</b> This class also doubles as a reader and writer of JavaScript Object
        Notation (JSON). The CBORObject.FromJSONString method converts JSON to a
        CBOR object, and the ToJSONString method converts a CBOR object to a
        JSON string.
      </para>
      <para>In addition, the CBORObject.WriteJSON method writes many kinds of
        objects as JSON to a data stream, including numbers, CBOR objects,
        strings, and arrays of numbers and strings. The CBORObject.Read method
        reads a CBOR object from a JSON data stream.
      </para>
      <para><b>Comparison Considerations:</b> </para>
      <para>Instances of CBORObject should not be compared for equality using the
        "==" operator; it's possible to create two CBOR objects with the same
        value but not the same reference. (The "==" operator might only check if
        each side of the operator is the same instance.)
      </para>
      <para>This class's natural ordering (under the CompareTo method) is not
        consistent with the Equals method. This means that two values that
        compare as equal under the CompareTo method might not be equal under the
        Equals method. This is important to consider especially if an
        application wants to compare numbers, since the CBOR number type
        supports numbers of different formats, such as big integers, rational
        numbers, and arbitrary-precision decimal numbers.
      </para>
      <para>Another consideration is that two values that are otherwise equal may
        have different tags. To strip the tags from a CBOR object before
        comparing, use the
        <c>Untag</c> method.
      </para>
      <para>To compare two numbers, the CompareToIgnoreTags or CompareTo method
        should be used. Which method to use depends on whether two equal values
        should still be considered equal if they have different tags.
      </para>
      <para>Although this class is inconsistent with the Equals method, it is safe
        to use CBORObject instances as hash keys as long as all of the keys are
        untagged text strings (which means GetTags returns an empty array and
        the Type property, or "getType()" in Java, returns TextString). This is
        because the natural ordering of these instances is consistent with the
        Equals method.
      </para>
      <para><b>Thread Safety:</b> </para>
      <para>CBOR objects that are numbers, "simple values", and text strings are
        immutable (their values can't be changed), so they are inherently safe
        for use by multiple threads.
      </para>
      <para>CBOR objects that are arrays, maps, and byte strings are mutable, but
        this class doesn't attempt to synchronize reads and writes to those
        objects by multiple threads, so those objects are not thread safe
        without such synchronization.
      </para>
      <para>One kind of CBOR object is called a map, or a list of key-value pairs.
        Keys can be any kind of CBOR object, including numbers, strings, arrays,
        and maps. However, text strings are the most suitable to use as keys;
        other kinds of CBOR object are much better used as map values instead,
        keeping in mind that some of them are not thread safe without
        synchronizing reads and writes to them.
      </para>
      <para>To find the type of a CBOR object, call its Type property (or
        "getType()" in Java). The return value can be Number, Boolean,
        SimpleValue, or TextString for immutable CBOR objects, and Array, Map,
        or ByteString for mutable CBOR objects.
      </para>
      <para><b>Nesting Depth:</b> </para>
      <para>The DecodeFromBytes and Read methods can only read objects with a
        limited maximum depth of arrays and maps nested within other arrays and
        maps. The code sets this maximum depth to 500 (allowing more than enough
        nesting for most purposes), but it's possible that stack overflows in
        some runtimes might lower the effective maximum nesting depth. When the
        nesting depth goes above 500, the DecodeFromBytes and Read methods throw
        a CBORException.
      </para>
      <para>The ReadJSON and FromJSONString methods currently have nesting depths of
        1000.
      </para>
    </remarks>
  </doc>
  <doc name='M:PeterO.Cbor.CBORObject.Abs'>
    <summary>Gets this object's absolute value.
    </summary>
    <returns>This object's absolute without its negative sign.
    </returns>
    <exception cref='T:System.InvalidOperationException'>This object's type is not a number type.
    </exception>
  </doc>
  <doc name='M:PeterO.Cbor.CBORObject.Add(PeterO.Cbor.CBORObject)'>
    <summary><para>Adds a new object to the end of this array. (Used to throw
        ArgumentNullException on a null reference, but now converts the null
        reference to CBORObject.Null, for convenience with the Object overload
        of this method).
      </para>
      <para>NOTE: This method can't be used to add a tag to an existing CBOR object.
        To create a CBOR object with a given tag, call the
        <c>CBORObject.FromObjectAndTag</c> method and pass the CBOR object and the desired tag number to that
        method.
      </para>
    </summary>
    <param name='obj'>The parameter
      <paramref name='obj'/>
       is a CBOR object.
    </param>
    <returns>This instance.
    </returns>
    <exception cref='T:System.InvalidOperationException'>This object is not an array.
    </exception>
    <example><para>The following example creates a CBOR array and adds several CBOR
        objects, one of which has a custom CBOR tag, to that array. Note the
        chaining behavior made possible by this method.
      </para>
      <code>CBORObject obj = CBORObject.NewArray() .Add(CBORObject.False)
        .Add(CBORObject.FromObject(5)) .Add(CBORObject.FromObject("text
        string")) .Add(CBORObject.FromObjectAndTag(9999, 1));</code> .
    </example>
  </doc>
  <doc name='M:PeterO.Cbor.CBORObject.Add(System.Object)'>
    <summary><para>Converts an object to a CBOR object and adds it to the end of this
        array.
      </para>
      <para>NOTE: This method can't be used to add a tag to an existing CBOR object.
        To create a CBOR object with a given tag, call the
        <c>CBORObject.FromObjectAndTag</c> method and pass the CBOR object and the desired tag number to that
        method.
      </para>
    </summary>
    <param name='obj'>A CBOR object (or an object convertible to a CBOR object) to add to this
      CBOR array.
    </param>
    <returns>This instance.
    </returns>
    <exception cref='T:System.InvalidOperationException'>This instance is not an array.
    </exception>
    <exception cref='T:System.ArgumentException'>The type of
      <paramref name='obj'/>
       is not supported.
    </exception>
    <example><para>The following example creates a CBOR array and adds several CBOR
        objects, one of which has a custom CBOR tag, to that array. Note the
        chaining behavior made possible by this method.
      </para>
      <code>CBORObject obj = CBORObject.NewArray() .Add(CBORObject.False) .Add(5)
        .Add("text string") .Add(CBORObject.FromObjectAndTag(9999, 1));</code> .
    </example>
  </doc>
  <doc name='M:PeterO.Cbor.CBORObject.Add(System.Object,System.Object)'>
    <summary><para>Adds a new key and its value to this CBOR map, or adds the value if the
        key doesn't exist.
      </para>
      <para>NOTE: This method can't be used to add a tag to an existing CBOR object.
        To create a CBOR object with a given tag, call the
        <c>CBORObject.FromObjectAndTag</c> method and pass the CBOR object and the desired tag number to that
        method.
      </para>
    </summary>
    <param name='key'>An object representing the key, which will be converted to a CBORObject.
      Can be null, in which case this value is converted to CBORObject.Null.
    </param>
    <param name='valueOb'>An object representing the value, which will be converted to a CBORObject.
      Can be null, in which case this value is converted to CBORObject.Null.
    </param>
    <returns>This instance.
    </returns>
    <exception cref='T:System.ArgumentException'>The parameter
      <paramref name='key'/>
       already exists in this map.
    </exception>
    <exception cref='T:System.InvalidOperationException'>This object is not a map.
    </exception>
    <exception cref='T:System.ArgumentException'>The parameter
      <paramref name='key'/>
       or
      <paramref name='valueOb'/>
       has an unsupported type.
    </exception>
  </doc>
  <doc name='M:PeterO.Cbor.CBORObject.AddConverter``1(System.Type,PeterO.Cbor.ICBORConverter{``0})'>
    <summary>Registers an object that converts objects of a given type to CBOR objects
      (called a CBOR converter).
    </summary>
    <param name='type'>A Type object specifying the type that the converter converts to CBOR
      objects.
    </param>
    <param name='converter'>The parameter
      <paramref name='converter'/>
       is an ICBORConverter object.
    </param>
    <typeparam name='T'>Must be the same as the "type" parameter.
    </typeparam>
    <exception cref='T:System.ArgumentNullException'>The parameter
      <paramref name='type'/>
       or
      <paramref name='converter'/>
       is null.
    </exception>
    <exception cref='T:System.ArgumentException'>Converter doesn't contain a proper ToCBORObject method".
    </exception>
  </doc>
  <doc name='M:PeterO.Cbor.CBORObject.AddTagHandler(PeterO.BigInteger,PeterO.Cbor.ICBORTag)'>
    <summary>Registers an object that validates CBOR objects with new tags.
    </summary>
    <param name='bigintTag'>An arbitrary-precision integer.
    </param>
    <param name='handler'>The parameter
      <paramref name='handler'/>
       is an ICBORTag object.
    </param>
    <exception cref='T:System.ArgumentNullException'>The parameter
      <paramref name='bigintTag'/>
       or
      <paramref name='handler'/>
       is null.
    </exception>
    <exception cref='T:System.ArgumentException'>The parameter
      <paramref name='bigintTag'/>
       is less than 0 or greater than (2^64-1).
    </exception>
  </doc>
  <doc name='M:PeterO.Cbor.CBORObject.AddTagHandler(PeterO.Numbers.EInteger,PeterO.Cbor.ICBORTag)'>
    <summary>Registers an object that validates CBOR objects with new tags.
    </summary>
    <param name='bigintTag'>An arbitrary-precision integer.
    </param>
    <param name='handler'>The parameter
      <paramref name='handler'/>
       is an ICBORTag object.
    </param>
    <exception cref='T:System.ArgumentNullException'>The parameter
      <paramref name='bigintTag'/>
       or
      <paramref name='handler'/>
       is null.
    </exception>
    <exception cref='T:System.ArgumentException'>The parameter
      <paramref name='bigintTag'/>
       is less than 0 or greater than (2^64-1).
    </exception>
  </doc>
  <doc name='M:PeterO.Cbor.CBORObject.Addition(PeterO.Cbor.CBORObject,PeterO.Cbor.CBORObject)'>
    <summary>Finds the sum of two CBOR numbers.
    </summary>
    <param name='first'>The parameter
      <paramref name='first'/>
       is a CBOR object.
    </param>
    <param name='second'>The parameter
      <paramref name='second'/>
       is a CBOR object.
    </param>
    <returns>A CBORObject object.
    </returns>
    <exception cref='T:System.ArgumentException'>Either or both operands are not numbers (as opposed to Not-a-Number, NaN).
    </exception>
  </doc>
  <doc name='M:PeterO.Cbor.CBORObject.AsBigInteger'>
    <summary>Converts this object to an arbitrary-precision integer. Fractional values
      are truncated to an integer.
    </summary>
    <returns>The closest big integer to this object.
    </returns>
    <exception cref='T:System.InvalidOperationException'>This object's type is not a number type, including if this object is
      CBORObject.Null.
    </exception>
    <exception cref='T:System.OverflowException'>This object's value is infinity or not-a-number (NaN).
    </exception>
  </doc>
  <doc name='M:PeterO.Cbor.CBORObject.AsBoolean'>
    <summary>Returns false if this object is False, Null, or Undefined; otherwise,true.
    </summary>
    <returns>False if this object is False, Null, or Undefined; otherwise,true.
    </returns>
  </doc>
  <doc name='M:PeterO.Cbor.CBORObject.AsByte'>
    <summary>Converts this object to a byte (0 to 255). Floating point values are
      truncated to an integer.
    </summary>
    <returns>The closest byte-sized integer to this object.
    </returns>
    <exception cref='T:System.InvalidOperationException'>This object's type is not a number type.
    </exception>
    <exception cref='T:System.OverflowException'>This object's value exceeds the range of a byte (would be less than 0 or
      greater than 255 when truncated to an integer).
    </exception>
  </doc>
  <doc name='M:PeterO.Cbor.CBORObject.AsDecimal'>
    <summary>Converts this object to a .NET decimal.
    </summary>
    <returns>The closest big integer to this object.
    </returns>
    <exception cref='T:System.InvalidOperationException'>This object's type is not a number type.
    </exception>
    <exception cref='T:System.OverflowException'>This object's value exceeds the range of a .NET decimal.
    </exception>
  </doc>
  <doc name='M:PeterO.Cbor.CBORObject.AsDouble'>
    <summary>Converts this object to a 64-bit floating point number.
    </summary>
    <returns>The closest 64-bit floating point number to this object. The return value
      can be positive infinity or negative infinity if this value exceeds the
      range of a 64-bit floating point number.
    </returns>
    <exception cref='T:System.InvalidOperationException'>This object's type is not a number type.
    </exception>
  </doc>
  <doc name='M:PeterO.Cbor.CBORObject.AsEDecimal'>
    <summary>Converts this object to a decimal number.
    </summary>
    <returns>A decimal number for this object's value. If this object is a rational
      number with a nonterminating decimal expansion, returns a decimal number
      rounded to 34 digits.
    </returns>
    <exception cref='T:System.InvalidOperationException'>This object's type is not a number type, including if this object is
      CBORObject.Null. To check the CBOR object for null before conversion, use
      the following idiom (originally written in C# for the .NET version):
      <c>(cbor == null || cbor.IsNull) ? null : cbor.AsEDecimal()</c> .
    </exception>
  </doc>
  <doc name='M:PeterO.Cbor.CBORObject.AsEFloat'>
    <summary>Converts this object to an arbitrary-precision binary floating point
      number.
    </summary>
    <returns>An arbitrary-precision binary floating point number for this object's
      value. Note that if this object is a decimal number with a fractional
      part, the conversion may lose information depending on the number. If this
      object is a rational number with a nonterminating binary expansion,
      returns a binary floating-point number rounded to a high but limited
      precision.
    </returns>
    <exception cref='T:System.InvalidOperationException'>This object's type is not a number type, including if this object is
      CBORObject.Null. To check the CBOR object for null before conversion, use
      the following idiom (originally written in C# for the .NET version):
      <c>(cbor == null || cbor.IsNull) ? null : cbor.AsEFloat()</c> .
    </exception>
  </doc>
  <doc name='M:PeterO.Cbor.CBORObject.AsEInteger'>
    <summary>Converts this object to an arbitrary-precision integer. Fractional values
      are truncated to an integer.
    </summary>
    <returns>The closest big integer to this object.
    </returns>
    <exception cref='T:System.InvalidOperationException'>This object's type is not a number type, including if this object is
      CBORObject.Null. To check the CBOR object for null before conversion, use
      the following idiom (originally written in C# for the .NET version):
      <c>(cbor == null || cbor.IsNull) ? null : cbor.AsEInteger()</c> .
    </exception>
    <exception cref='T:System.OverflowException'>This object's value is infinity or not-a-number (NaN).
    </exception>
  </doc>
  <doc name='M:PeterO.Cbor.CBORObject.AsERational'>
    <summary>Converts this object to a rational number.
    </summary>
    <returns>A rational number for this object's value.
    </returns>
    <exception cref='T:System.InvalidOperationException'>This object's type is not a number type, including if this object is
      CBORObject.Null. To check the CBOR object for null before conversion, use
      the following idiom (originally written in C# for the .NET version):
      <c>(cbor == null || cbor.IsNull) ? null : cbor.AsERational()</c> .
    </exception>
  </doc>
  <doc name='M:PeterO.Cbor.CBORObject.AsInt16'>
    <summary>Converts this object to a 16-bit signed integer. Floating point values are
      truncated to an integer.
    </summary>
    <returns>The closest 16-bit signed integer to this object.
    </returns>
    <exception cref='T:System.InvalidOperationException'>This object's type is not a number type.
    </exception>
    <exception cref='T:System.OverflowException'>This object's value exceeds the range of a 16-bit signed integer.
    </exception>
  </doc>
  <doc name='M:PeterO.Cbor.CBORObject.AsInt32'>
    <summary>Converts this object to a 32-bit signed integer. Non-integer number values
      are truncated to an integer. (NOTE: To determine whether this method call
      can succeed, call the
      <b>CanTruncatedIntFitInInt32</b> method before calling this method. Checking whether this object's type is

      <c>CBORType.Number</c> is not sufficient. See the example.).
    </summary>
    <returns>The closest 32-bit signed integer to this object.
    </returns>
    <exception cref='T:System.InvalidOperationException'>This object's type is not a number type.
    </exception>
    <exception cref='T:System.OverflowException'>This object's value exceeds the range of a 32-bit signed integer.
    </exception>
    <example><para>The following example code (originally written in C# for the .NET
        Framework) shows a way to check whether a given CBOR object stores a
        32-bit signed integer before getting its value.
      </para>
      <code>CBORObject obj = CBORObject.FromInt32(99999); if&#x28;obj.IsIntegral
        &amp;&amp; obj.CanTruncatedIntFitInInt32&#x28;)) &#x7b; // Not an Int32;
        handle the error Console.WriteLine("Not a 32-bit integer."); &#x7d; else
        { Console.WriteLine("The value is " + obj.AsInt32()); }</code> .
    </example>
  </doc>
  <doc name='M:PeterO.Cbor.CBORObject.AsInt64'>
    <summary>Converts this object to a 64-bit signed integer. Non-integer numbers are
      truncated to an integer. (NOTE: To determine whether this method call can
      succeed, call the
      <b>CanTruncatedIntFitInInt64</b> method before calling this method. Checking whether this object's type is

      <c>CBORType.Number</c> is not sufficient. See the example.).
    </summary>
    <returns>The closest 64-bit signed integer to this object.
    </returns>
    <exception cref='T:System.InvalidOperationException'>This object's type is not a number type.
    </exception>
    <exception cref='T:System.OverflowException'>This object's value exceeds the range of a 64-bit signed integer.
    </exception>
    <example><para>The following example code (originally written in C# for the .NET
        Framework) shows a way to check whether a given CBOR object stores a
        64-bit signed integer before getting its value.
      </para>
      <code>CBORObject obj = CBORObject.FromInt64(99999); if&#x28;obj.IsIntegral
        &amp;&amp; obj.CanTruncatedIntFitInInt64&#x28;)) &#x7b; // Not an Int64;
        handle the error Console.WriteLine("Not a 64-bit integer."); &#x7d; else
        { Console.WriteLine("The value is " + obj.AsInt64()); }</code> .
    </example>
  </doc>
  <doc name='M:PeterO.Cbor.CBORObject.AsSByte'>
    <summary>Converts this object to an 8-bit signed integer.
    </summary>
    <returns>An 8-bit signed integer.
    </returns>
  </doc>
  <doc name='M:PeterO.Cbor.CBORObject.AsSingle'>
    <summary>Converts this object to a 32-bit floating point number.
    </summary>
    <returns>The closest 32-bit floating point number to this object. The return value
      can be positive infinity or negative infinity if this object's value
      exceeds the range of a 32-bit floating point number.
    </returns>
    <exception cref='T:System.InvalidOperationException'>This object's type is not a number type.
    </exception>
  </doc>
  <doc name='M:PeterO.Cbor.CBORObject.AsString'>
    <summary>Gets the value of this object as a text string.
    </summary>
    <returns>Gets this object's string.
    </returns>
    <exception cref='T:System.InvalidOperationException'>This object's type is not a string, including if this object is
      CBORObject.Null. To check the CBOR object for null before conversion, use
      the following idiom (originally written in C# for the .NET version):
      <c>(cbor == null || cbor.IsNull) ? null : cbor.AsString()</c> .
    </exception>
  </doc>
  <doc name='M:PeterO.Cbor.CBORObject.AsUInt16'>
    <summary>Converts this object to a 16-bit unsigned integer. The return value will
      be truncated as necessary.
    </summary>
    <returns>A 16-bit unsigned integer.
    </returns>
    <exception cref='T:System.OverflowException'>This object's value is outside the range of a 16-bit unsigned integer.
    </exception>
  </doc>
  <doc name='M:PeterO.Cbor.CBORObject.AsUInt32'>
    <summary>Converts this object to a 32-bit unsigned integer. The return value will
      be truncated as necessary.
    </summary>
    <returns>A 32-bit unsigned integer.
    </returns>
    <exception cref='T:System.OverflowException'>This object's value is outside the range of a 32-bit unsigned integer.
    </exception>
  </doc>
  <doc name='M:PeterO.Cbor.CBORObject.AsUInt64'>
    <summary>Converts this object to a 64-bit unsigned integer. Non-integer values are
      truncated to an integer.
    </summary>
    <returns>The closest big integer to this object.
    </returns>
    <exception cref='T:System.InvalidOperationException'>This object's type is not a number type.
    </exception>
    <exception cref='T:System.OverflowException'>This object's value exceeds the range of a 64-bit unsigned integer.
    </exception>
  </doc>
  <doc name='M:PeterO.Cbor.CBORObject.CanFitInDouble'>
    <summary>Returns whether this object's value can be converted to a 64-bit floating
      point number without its value being rounded to another numerical value.
    </summary>
    <returns>Whether this object's value can be converted to a 64-bit floating point
      number without its value being rounded to another numerical value. Returns
      true if this is a not-a-number value, even if the value's diagnostic
      information can' t fit in a 64-bit floating point number.
    </returns>
  </doc>
  <doc name='M:PeterO.Cbor.CBORObject.CanFitInInt32'>
    <summary>Returns whether this object's numerical value is an integer, is -(2^31) or
      greater, and is less than 2^31.
    </summary>
    <returns><c>true</c> if this object's numerical value is an integer, is -(2^31) or greater,
      and is less than 2^31; otherwise,
      <c>false</c> .
    </returns>
  </doc>
  <doc name='M:PeterO.Cbor.CBORObject.CanFitInInt64'>
    <summary>Returns whether this object's numerical value is an integer, is -(2^63) or
      greater, and is less than 2^63.
    </summary>
    <returns><c>true</c> if this object's numerical value is an integer, is -(2^63) or greater,
      and is less than 2^63; otherwise,
      <c>false</c> .
    </returns>
  </doc>
  <doc name='M:PeterO.Cbor.CBORObject.CanFitInSingle'>
    <summary>Returns whether this object's value can be converted to a 32-bit floating
      point number without its value being rounded to another numerical value.
    </summary>
    <returns>Whether this object's value can be converted to a 32-bit floating point
      number without its value being rounded to another numerical value. Returns
      true if this is a not-a-number value, even if the value's diagnostic
      information can' t fit in a 32-bit floating point number.
    </returns>
  </doc>
  <doc name='M:PeterO.Cbor.CBORObject.CanTruncatedIntFitInInt32'>
    <summary>Returns whether this object's value, truncated to an integer, would be
      -(2^31) or greater, and less than 2^31.
    </summary>
    <returns><c>true</c> if this object's value, truncated to an integer, would be -(2^31) or
      greater, and less than 2^31; otherwise,
      <c>false</c> .
    </returns>
  </doc>
  <doc name='M:PeterO.Cbor.CBORObject.CanTruncatedIntFitInInt64'>
    <summary>Returns whether this object's value, truncated to an integer, would be
      -(2^63) or greater, and less than 2^63.
    </summary>
    <returns><c>true</c> if this object's value, truncated to an integer, would be -(2^63) or
      greater, and less than 2^63; otherwise,
      <c>false</c> .
    </returns>
  </doc>
  <doc name='M:PeterO.Cbor.CBORObject.Clear'>
    <summary>Removes all items from this CBOR array or all keys and values from this
      CBOR map.
    </summary>
    <exception cref='T:System.InvalidOperationException'>This object is not a CBOR array or CBOR map.
    </exception>
  </doc>
  <doc name='M:PeterO.Cbor.CBORObject.CompareTo(PeterO.Cbor.CBORObject)'>
    <summary>Compares two CBOR objects.
      <para>In this implementation:
      </para>
      <list type=''>
        <item>The null pointer (null reference) is considered less than any other
          object.
        </item>
        <item>If either object is true, false, CBORObject.Null, or the undefined
          value, it is treated as less than the other value. If both objects
          have one of these four values, then undefined is less than
          CBORObject.Null, which is less than false, which is less than true.
        </item>
        <item>If both objects are numbers, their mathematical values are compared.
          Here, NaN (not-a-number) is considered greater than any number.
        </item>
        <item>If both objects are simple values other than true, false,
          CBORObject.Null, and the undefined value, the objects are compared
          according to their ordinal numbers.
        </item>
        <item>If both objects are arrays, each element is compared. If one array is
          shorter than the other and the other array begins with that array (for
          the purposes of comparison), the shorter array is considered less than
          the longer array.
        </item>
        <item>If both objects are strings, compares each string code-point by
          code-point, as though by the DataUtilities.CodePointCompare method.
        </item>
        <item>If both objects are maps, compares each map as though each were an
          array with the sorted keys of that map as the array's elements. If
          both maps have the same keys, their values are compared in the order
          of the sorted keys.
        </item>
        <item>If each object is a different type, then they are sorted by their type
          number, in the order given for the CBORType enumeration.
        </item>
        <item>If each object has different tags and both objects are otherwise equal
          under this method, each element is compared as though each were an
          array with that object's tags listed in order from outermost to
          innermost.
        </item>
      </list>
      <para>This method is not consistent with the Equals method.
      </para>
    </summary>
    <param name='other'>A value to compare with.
    </param>
    <returns>Less than 0, if this value is less than the other object; or 0, if both
      values are equal; or greater than 0, if this value is less than the other
      object or if the other object is null.
    </returns>
    <exception cref='T:System.ArgumentException'>An internal error occurred.
    </exception>
  </doc>
  <doc name='M:PeterO.Cbor.CBORObject.CompareToIgnoreTags(PeterO.Cbor.CBORObject)'>
    <summary>Compares this object and another CBOR object, ignoring the tags they have,
      if any. See the CompareTo method for more information on the comparison
      function.
    </summary>
    <param name='other'>A value to compare with.
    </param>
    <returns>Less than 0, if this value is less than the other object; or 0, if both
      values are equal; or greater than 0, if this value is less than the other
      object or if the other object is null.
    </returns>
  </doc>
  <doc name='M:PeterO.Cbor.CBORObject.ContainsKey(PeterO.Cbor.CBORObject)'>
    <summary>Determines whether a value of the given key exists in this object.
    </summary>
    <param name='key'>An object that serves as the key. If this is
      <c>null</c> , checks for
      <c>CBORObject.Null</c> .
    </param>
    <returns><c>true</c> if the given key is found, or false if the given key is not found or this
      object is not a map.
    </returns>
  </doc>
  <doc name='M:PeterO.Cbor.CBORObject.ContainsKey(System.Object)'>
    <summary>Determines whether a value of the given key exists in this object.
    </summary>
    <param name='objKey'>The parameter
      <paramref name='objKey'/>
       is an arbitrary object.
    </param>
    <returns><c>true</c> if the given key is found, or false if the given key is not found or this
      object is not a map.
    </returns>
  </doc>
  <doc name='M:PeterO.Cbor.CBORObject.ContainsKey(System.String)'>
    <summary>Determines whether a value of the given key exists in this object.
    </summary>
    <param name='key'>A string that serves as the key. If this is
      <c>null</c> , checks for
      <c>CBORObject.Null</c> .
    </param>
    <returns><c>true</c> if the given key (as a CBOR object) is found, or false if the given key
      is not found or this object is not a map.
    </returns>
  </doc>
  <doc name='P:PeterO.Cbor.CBORObject.ConverterInfo.Converter'>
    <summary>Gets or sets the ICBORConverter object.
    </summary>
    <value>The ICBORConverter object.
    </value>
  </doc>
  <doc name='P:PeterO.Cbor.CBORObject.ConverterInfo.ToObject'>
    <summary>Gets or sets the converter's ToCBORObject method.
    </summary>
    <value>The converter&apos;s ToCBORObject method.
    </value>
  </doc>
  <doc name='P:PeterO.Cbor.CBORObject.Count'>
    <summary>Gets the number of keys in this map, or the number of items in this array,
      or 0 if this item is neither an array nor a map.
    </summary>
    <value>The number of keys in this map, or the number of items in this array, or 0
      if this item is neither an array nor a map.
    </value>
  </doc>
  <doc name='M:PeterO.Cbor.CBORObject.DecodeFromBytes(System.Byte[])'>
    <summary><para>Generates a CBOR object from an array of CBOR-encoded bytes.
      </para>
    </summary>
    <param name='data'>A byte array in which a single CBOR object is encoded.
    </param>
    <returns>A CBOR object decoded from the given byte array.
    </returns>
    <exception cref='T:PeterO.Cbor.CBORException'>There was an error in reading or parsing the data. This includes cases
      where not all of the byte array represents a CBOR object. This exception
      is also thrown if the parameter
      <paramref name='data'/>
       is empty.
    </exception>
    <exception cref='T:System.ArgumentNullException'>The parameter
      <paramref name='data'/>
       is null.
    </exception>
  </doc>
  <doc name='M:PeterO.Cbor.CBORObject.DecodeFromBytes(System.Byte[],PeterO.Cbor.CBOREncodeOptions)'>
    <summary>Generates a CBOR object from an array of CBOR-encoded bytes, using the
      given
      <c>CBOREncodeOptions</c> object to control the decoding process.
    </summary>
    <param name='data'>A byte array in which a single CBOR object is encoded.
    </param>
    <param name='options'>The parameter
      <paramref name='options'/>
       is a CBOREncodeOptions object.
    </param>
    <returns>A CBOR object decoded from the given byte array.
    </returns>
    <exception cref='T:PeterO.Cbor.CBORException'>There was an error in reading or parsing the data. This includes cases
      where not all of the byte array represents a CBOR object. This exception
      is also thrown if the parameter
      <paramref name='data'/>
       is empty.
    </exception>
    <exception cref='T:System.ArgumentNullException'>The parameter
      <paramref name='data'/>
       is null.
    </exception>
    <example><para>The following example (originally written in C# for the .NET version)
        implements a method that decodes a text string from a CBOR byte array.
        It's successful only if the CBOR object contains an untagged text
        string.
      </para>
      <code>private static String DecodeTextString&#x28;byte[] bytes)&#x7b;
        if&#x28;bytes == null)&#x7b; throw new
        ArgumentNullException&#x28;nameof(mapObj));&#x7d; if&#x28;bytes.Length
        == 0 || bytes[0]&lt;0x60 || bytes[0]&gt;0x7f)&#x7b;throw new
        CBORException&#x28;);&#x7d; return
        CBORObject.DecodeFromBytes&#x28;bytes,
        CBOREncodeOptions.Default).AsString&#x28;); &#x7d;</code> .
    </example>
  </doc>
  <doc name='M:PeterO.Cbor.CBORObject.Divide(PeterO.Cbor.CBORObject,PeterO.Cbor.CBORObject)'>
    <summary>Divides a CBORObject object by the value of a CBORObject object.
    </summary>
    <param name='first'>The parameter
      <paramref name='first'/>
       is a CBOR object.
    </param>
    <param name='second'>The parameter
      <paramref name='second'/>
       is a CBOR object.
    </param>
    <returns>The quotient of the two objects.
    </returns>
  </doc>
  <doc name='M:PeterO.Cbor.CBORObject.EncodeToBytes'>
    <summary><para>Writes the binary representation of this CBOR object and returns a byte
        array of that representation. If the CBOR object contains CBOR maps, or
        is a CBOR map itself, the keys to the map are written out to the byte
        array in an undefined order. The example code given in
        <see cref='M:PeterO.Cbor.CBORObject.WriteTo(System.IO.Stream)'/>
         can be used to write out certain keys of a CBOR map in a given order.
        For the CTAP2 canonical ordering, which is useful for implementing Web
        Authentication, call
        <c>EncodeToBytes(new CBOREncodeOptions(false,false,true))</c> rather than this method.
      </para>
    </summary>
    <returns>A byte array in CBOR format.
    </returns>
  </doc>
  <doc name='M:PeterO.Cbor.CBORObject.EncodeToBytes(PeterO.Cbor.CBOREncodeOptions)'>
    <summary>Writes the binary representation of this CBOR object and returns a byte
      array of that representation, using the specified options for encoding the
      object to CBOR format. For the CTAP2 canonical ordering, which is useful
      for implementing Web Authentication, call this method as follows:
      <c>EncodeToBytes(new CBOREncodeOptions(false, false, true))</c> .
    </summary>
    <param name='options'>Options for encoding the data to CBOR.
    </param>
    <returns>A byte array in CBOR format.
    </returns>
    <exception cref='T:System.ArgumentNullException'>The parameter
      <paramref name='options'/>
       is null.
    </exception>
  </doc>
  <doc name='M:PeterO.Cbor.CBORObject.Equals(PeterO.Cbor.CBORObject)'>
    <summary>Compares the equality of two CBOR objects. Not-a-number values can be
      considered equal by this method.
    </summary>
    <param name='other'>The object to compare.
    </param>
    <returns><c>true</c> if the objects are equal; otherwise,
      <c>false</c> .
    </returns>
  </doc>
  <doc name='M:PeterO.Cbor.CBORObject.Equals(System.Object)'>
    <summary>Determines whether this object and another object are equal and have the
      same type. Not-a-number values can be considered equal by this method.
    </summary>
    <param name='obj'>The parameter
      <paramref name='obj'/>
       is an arbitrary object.
    </param>
    <returns><c>true</c> if the objects are equal; otherwise,
      <c>false</c> .
    </returns>
  </doc>
  <doc name='F:PeterO.Cbor.CBORObject.False'>
    <summary>Represents the value false.
    </summary>
  </doc>
  <doc name='M:PeterO.Cbor.CBORObject.FromJSONString(System.String)'>
    <summary><para>Generates a CBOR object from a text string in JavaScript Object Notation
        (JSON) format.
      </para>
      <para>If a JSON object has duplicate keys, a CBORException is thrown. This is
        a change in version 4.0.
      </para>
      <para>Note that if a CBOR object is converted to JSON with
        <c>ToJSONString</c> , then the JSON is converted back to CBOR with this method, the new
        CBOR object will not necessarily be the same as the old CBOR object,
        especially if the old CBOR object uses data types not supported in JSON,
        such as integers in map keys.
      </para>
    </summary>
    <param name='str'>A string in JSON format. The entire string must contain a single JSON
      object and not multiple objects. The string may not begin with a
      byte-order mark (U+FEFF).
    </param>
    <returns>A CBOR object.
    </returns>
    <exception cref='T:System.ArgumentNullException'>The parameter
      <paramref name='str'/>
       is null.
    </exception>
    <exception cref='T:PeterO.Cbor.CBORException'>The string is not in JSON format.
    </exception>
  </doc>
  <doc name='M:PeterO.Cbor.CBORObject.FromJSONString(System.String,PeterO.Cbor.CBOREncodeOptions)'>
    <summary>Generates a CBOR object from a text string in JavaScript Object Notation
      (JSON) format, using the specified options to control the decoding
      process.
      <para>Note that if a CBOR object is converted to JSON with
        <c>ToJSONString</c> , then the JSON is converted back to CBOR with this method, the new
        CBOR object will not necessarily be the same as the old CBOR object,
        especially if the old CBOR object uses data types not supported in JSON,
        such as integers in map keys.
      </para>
    </summary>
    <param name='str'>A string in JSON format. The entire string must contain a single JSON
      object and not multiple objects. The string may not begin with a
      byte-order mark (U+FEFF).
    </param>
    <param name='options'>Specifies options to control the decoding process.
    </param>
    <returns>A CBORObject object.
    </returns>
    <exception cref='T:System.ArgumentNullException'>The parameter
      <paramref name='str'/>
       or
      <paramref name='options'/>
       is null.
    </exception>
    <exception cref='T:PeterO.Cbor.CBORException'>The string is not in JSON format.
    </exception>
  </doc>
  <doc name='M:PeterO.Cbor.CBORObject.FromObject(PeterO.BigInteger)'>
    <summary>Generates a CBOR object from an arbitrary-precision integer.
    </summary>
    <param name='bigintValue'>An arbitrary-precision value.
    </param>
    <returns>A CBOR number.
    </returns>
  </doc>
  <doc name='M:PeterO.Cbor.CBORObject.FromObject(PeterO.Cbor.CBORObject)'>
    <summary>Generates a CBOR object from a CBOR object.
    </summary>
    <param name='value'>The parameter
      <paramref name='value'/>
       is a CBOR object.
    </param>
    <returns>Same as.
    </returns>
  </doc>
  <doc name='M:PeterO.Cbor.CBORObject.FromObject(PeterO.Cbor.CBORObject[])'>
    <summary>Generates a CBOR object from an array of CBOR objects.
    </summary>
    <param name='array'>An array of CBOR objects.
    </param>
    <returns>A CBOR object where each element of the given array is copied to a new
      array, or CBORObject.Null if the value is null.
    </returns>
  </doc>
  <doc name='M:PeterO.Cbor.CBORObject.FromObject(PeterO.ExtendedDecimal)'>
    <summary>Generates a CBOR object from a decimal number.
    </summary>
    <param name='otherValue'>An arbitrary-precision decimal number.
    </param>
    <returns>A CBOR number.
    </returns>
  </doc>
  <doc name='M:PeterO.Cbor.CBORObject.FromObject(PeterO.ExtendedFloat)'>
    <summary>Generates a CBOR object from an arbitrary-precision binary floating-point
      number.
    </summary>
    <param name='bigValue'>An arbitrary-precision binary floating-point number.
    </param>
    <returns>A CBOR number.
    </returns>
  </doc>
  <doc name='M:PeterO.Cbor.CBORObject.FromObject(PeterO.ExtendedRational)'>
    <summary>Generates a CBOR object from an arbitrary-precision binary floating-point
      number.
    </summary>
    <param name='bigValue'>An arbitrary-precision binary floating-point number.
    </param>
    <returns>A CBOR number.
    </returns>
  </doc>
  <doc name='M:PeterO.Cbor.CBORObject.FromObject(PeterO.Numbers.EDecimal)'>
    <summary>Generates a CBOR object from a decimal number.
    </summary>
    <param name='otherValue'>An arbitrary-precision decimal number.
    </param>
    <returns>A CBOR number.
    </returns>
  </doc>
  <doc name='M:PeterO.Cbor.CBORObject.FromObject(PeterO.Numbers.EFloat)'>
    <summary>Generates a CBOR object from an arbitrary-precision binary floating-point
      number.
    </summary>
    <param name='bigValue'>An arbitrary-precision binary floating-point number.
    </param>
    <returns>A CBOR number.
    </returns>
  </doc>
  <doc name='M:PeterO.Cbor.CBORObject.FromObject(PeterO.Numbers.EInteger)'>
    <summary>Generates a CBOR object from an arbitrary-precision integer.
    </summary>
    <param name='bigintValue'>An arbitrary-precision value.
    </param>
    <returns>A CBOR number.
    </returns>
  </doc>
  <doc name='M:PeterO.Cbor.CBORObject.FromObject(PeterO.Numbers.ERational)'>
    <summary>Generates a CBOR object from a rational number.
    </summary>
    <param name='bigValue'>A rational number.
    </param>
    <returns>A CBOR number.
    </returns>
  </doc>
  <doc name='M:PeterO.Cbor.CBORObject.FromObject(System.Boolean)'>
    <summary>Returns the CBOR true value or false value, depending on "value".
    </summary>
    <param name='value'>Either True or False.
    </param>
    <returns>CBORObject.True if value is true; otherwise CBORObject.False.
    </returns>
  </doc>
  <doc name='M:PeterO.Cbor.CBORObject.FromObject(System.Byte)'>
    <summary>Generates a CBOR object from a byte (0 to 255).
    </summary>
    <param name='value'>The parameter
      <paramref name='value'/>
       is a byte (from 0 to 255).
    </param>
    <returns>A CBORObject object.
    </returns>
  </doc>
  <doc name='M:PeterO.Cbor.CBORObject.FromObject(System.Byte[])'>
    <summary><para>Generates a CBOR object from a byte array. The byte array is copied to a
        new byte array. (This method can't be used to decode CBOR data from a
        byte array; for that, use the DecodeFromBytes method instead.).
      </para>
    </summary>
    <param name='bytes'>A byte array. Can be null.
    </param>
    <returns>A CBOR byte string object where each byte of the given byte array is
      copied to a new array, or CBORObject.Null if the value is null.
    </returns>
    <example><para>The following example encodes a text string to a UTF-8 byte array, then
        uses the array to create a CBOR byte string object. It is not
        recommended to use
        <c>Encoding.UTF8.GetBytes</c> in .NET, or the
        <c>getBytes()</c> method in Java to do this. For instance,
        <c>getBytes()</c> encodes text strings in a default (so not fixed) character encoding,
        which can be undesirable. Instead, use the
        <c>DataUtilities.GetUtf8Bytes</c> method to convert text strings to UTF-8.
      </para>
      <code>/* true does character replacement of invalid UTF-8; false throws an
        exception on invalid UTF-8 */ byte[] bytes = DataUtilities.GetUtf8Bytes(
        textString, true); CBORObject cbor = CBORObject.FromBytes(bytes);</code> .
    </example>
  </doc>
  <doc name='M:PeterO.Cbor.CBORObject.FromObject(System.Char)'>
    <summary>Generates a CBOR string object from a Unicode character.
    </summary>
    <param name='value'>The parameter
      <paramref name='value'/>
       is a char object.
    </param>
    <returns>A CBORObject object.
    </returns>
    <exception cref='T:System.ArgumentException'>The parameter
      <paramref name='value'/>
       is a surrogate code point.
    </exception>
  </doc>
  <doc name='M:PeterO.Cbor.CBORObject.FromObject(System.Decimal)'>
    <summary>Converts a .NET decimal to a CBOR object.
    </summary>
    <param name='value'>The parameter
      <paramref name='value'/>
       is a Decimal object.
    </param>
    <returns>A CBORObject object with the same value as the .NET decimal.
    </returns>
  </doc>
  <doc name='M:PeterO.Cbor.CBORObject.FromObject(System.Double)'>
    <summary>Generates a CBOR object from a 64-bit floating-point number.
    </summary>
    <param name='value'>The parameter
      <paramref name='value'/>
       is a 64-bit floating-point number.
    </param>
    <returns>A CBORObject object.
    </returns>
  </doc>
  <doc name='M:PeterO.Cbor.CBORObject.FromObject(System.Int16)'>
    <summary>Generates a CBOR object from a 16-bit signed integer.
    </summary>
    <param name='value'>The parameter
      <paramref name='value'/>
       is a 16-bit signed integer.
    </param>
    <returns>A CBORObject object.
    </returns>
  </doc>
  <doc name='M:PeterO.Cbor.CBORObject.FromObject(System.Int32)'>
    <summary>Generates a CBOR object from a 32-bit signed integer.
    </summary>
    <param name='value'>The parameter
      <paramref name='value'/>
       is a 32-bit signed integer.
    </param>
    <returns>A CBORObject object.
    </returns>
  </doc>
  <doc name='M:PeterO.Cbor.CBORObject.FromObject(System.Int32[])'>
    <summary>Generates a CBOR object from an array of 32-bit integers.
    </summary>
    <param name='array'>An array of 32-bit integers.
    </param>
    <returns>A CBOR array object where each element of the given array is copied to a
      new array, or CBORObject.Null if the value is null.
    </returns>
  </doc>
  <doc name='M:PeterO.Cbor.CBORObject.FromObject(System.Int64)'>
    <summary>Generates a CBOR object from a 64-bit signed integer.
    </summary>
    <param name='value'>The parameter
      <paramref name='value'/>
       is a 64-bit signed integer.
    </param>
    <returns>A CBORObject object.
    </returns>
  </doc>
  <doc name='M:PeterO.Cbor.CBORObject.FromObject(System.Int64[])'>
    <summary>Generates a CBOR object from an array of 64-bit integers.
    </summary>
    <param name='array'>An array of 64-bit integers.
    </param>
    <returns>A CBOR array object where each element of the given array is copied to a
      new array, or CBORObject.Null if the value is null.
    </returns>
  </doc>
  <doc name='M:PeterO.Cbor.CBORObject.FromObject(System.Object)'>
    <summary>Generates a CBORObject from an arbitrary object. See the overload of this
      method that takes CBORTypeMapper and PODOptions arguments.
    </summary>
    <param name='obj'>The parameter
      <paramref name='obj'/>
       is an arbitrary object.
      <para><b>NOTE:</b> For security reasons, whenever possible, an application should not base
        this parameter on user input or other externally supplied data unless
        the application limits this parameter's inputs to types specially
        handled by this method (such as
        <c>int</c> or
        <c>String</c> ) and/or to plain-old-data types (POCO or POJO types) within the
        control of the application. If the plain-old-data type references other
        data types, those types should likewise meet either criterion above.
      </para>
       .
    </param>
    <returns>A CBOR object corresponding to the given object. Returns CBORObject.Null
      if the object is null.
    </returns>
  </doc>
  <doc name='M:PeterO.Cbor.CBORObject.FromObject(System.Object,PeterO.Cbor.CBORTypeMapper)'>
    <summary>Generates a CBORObject from an arbitrary object. See the overload of this
      method that takes CBORTypeMapper and PODOptions arguments.
    </summary>
    <param name='obj'>The parameter
      <paramref name='obj'/>
       is an arbitrary object.
      <para><b>NOTE:</b> For security reasons, whenever possible, an application should not base
        this parameter on user input or other externally supplied data unless
        the application limits this parameter's inputs to types specially
        handled by this method (such as
        <c>int</c> or
        <c>String</c> ) and/or to plain-old-data types (POCO or POJO types) within the
        control of the application. If the plain-old-data type references other
        data types, those types should likewise meet either criterion above.
      </para>
       .
    </param>
    <param name='mapper'>An object containing optional converters to convert objects of certain
      types to CBOR objects.
    </param>
    <returns>A CBOR object corresponding to the given object. Returns CBORObject.Null
      if the object is null.
    </returns>
    <exception cref='T:System.ArgumentNullException'>The parameter
      <paramref name='mapper'/>
       is null.
    </exception>
  </doc>
  <doc name='M:PeterO.Cbor.CBORObject.FromObject(System.Object,PeterO.Cbor.CBORTypeMapper,PeterO.Cbor.PODOptions)'>
    <summary><para>Generates a CBORObject from an arbitrary object, using the given options
        to control how certain objects are converted to CBOR objects. The
        following cases are checked in the logical order given (rather than the
        strict order in which they are implemented by this library):
      </para>
      <list>
        <item><c>null</c> is converted to
          <c>CBORObject.Null</c> .
        </item>
        <item>A
          <c>CBORObject</c> is returned as itself.
        </item>
        <item>If the object is of a type corresponding to a type converter mentioned
          in the
          <paramref name='mapper'/>
           parameter, that converter will be used to convert the object to a
          CBOR object. Type converters can be used to override the default
          conversion behavior of almost any object.
        </item>
        <item>A
          <c>char</c> is converted to an integer (from 0 through 65535), and returns a CBOR
          object of that integer. (This is a change in version 4.0 from previous
          versions, which converted
          <c>char</c> , except surrogate code points from 0xd800 through 0xdfff, into
          single-character text strings.)
        </item>
        <item>A
          <c>bool</c> (
          <c>boolean</c> in Java) is converted to
          <c>CBORObject.True</c> or
          <c>CBORObject.False</c> .
        </item>
        <item>A
          <c>byte</c> is converted to a CBOR integer from 0 through 255.
        </item>
        <item>A primitive integer type (
          <c>int</c> ,
          <c>short</c> ,
          <c>long</c> , as well as
          <c>sbyte</c> ,
          <c>ushort</c> ,
          <c>uint</c> , and
          <c>ulong</c> in .NET) is converted to the corresponding CBOR integer.
        </item>
        <item>A primitive floating-point type (
          <c>float</c> ,
          <c>double</c> , as well as
          <c>decimal</c> in .NET) is converted to the corresponding CBOR number.
        </item>
        <item>A
          <c>String</c> is converted to a CBOR text string. To create a CBOR byte string
          object from
          <c>String</c> , see the example given in
          <see cref='M:PeterO.Cbor.CBORObject.FromObject(System.Byte[])'/>
           .
        </item>
        <item>In the .NET version, a nullable is converted to
          <c>CBORObject.Null</c> if the nullable's value is
          <c>null</c> , or converted according to the nullable's underlying type, if that
          type is supported by this method.
        </item>
        <item>A number of type
          <c>EDecimal</c> ,
          <c>EFloat</c> ,
          <c>EInteger</c> , and
          <c>ERational</c> in the
          <a href='https://www.nuget.org/packages/PeterO.Numbers'>
            <c>PeterO.Numbers</c> </a>
           library (in .NET) or the
          <a href='https://github.com/peteroupc/numbers-java'>
            <c>com.github.peteroupc/numbers</c> </a>
           artifact (in Java) is converted to the corresponding CBOR number.
        </item>
        <item>An array other than
          <c>byte[]</c> is converted to a CBOR array. In the .NET version, a multidimensional
          array is converted to an array of arrays.
        </item>
        <item>A
          <c>byte[]</c> (1-dimensional byte array) is converted to a CBOR byte string; the
          byte array is copied to a new byte array in this process. (This method
          can't be used to decode CBOR data from a byte array; for that, use the

          <b>DecodeFromBytes</b> method instead.)
        </item>
        <item>An object implementing IDictionary (Map in Java) is converted to a
          CBOR map containing the keys and values enumerated.
        </item>
        <item>An object implementing IEnumerable (Iterable in Java) is converted to
          a CBOR array containing the items enumerated.
        </item>
        <item>An enumeration (
          <c>Enum</c> ) object is converted to its
          <i>
             underlying value
          </i>
           in the .NET version, or the result of its
          <c>ordinal()</c> method in the Java version.
        </item>
        <item>An object of type
          <c>DateTime</c> ,
          <c>Uri</c> , or
          <c>Guid</c> (
          <c>Date</c> ,
          <c>URI</c> , or
          <c>UUID</c> , respectively, in Java) will be converted to a tagged CBOR object of
          the appropriate kind.
          <c>DateTime</c> /
          <c>Date</c> will be converted to a tag-0 string following the date format used in
          the Atom syndication format.
        </item>
        <item>If the object is a type not specially handled above, this method
          checks the
          <paramref name='obj'/>
           parameter for eligible getters as follows:
        </item>
        <item>(*) In the .NET version, eligible getters are the public, nonstatic
          getters of read/write properties (and also those of read-only
          properties in the case of a compiler-generated type). If a class has
          two properties of the form "X" and "IsX", where "X" is any name, or
          has multiple properties with the same name, those properties are
          ignored.
        </item>
        <item>(*) In the Java version, eligible getters are public, nonstatic
          methods starting with "get" or "is" (either word followed by a
          character other than a basic digit or lower-case letter, that is,
          other than "a" to "z" or "0" to "9"), that take no parameters and do
          not return void, except that methods named "getClass" are not eligible
          getters. If a class has two otherwise eligible getters of the form
          "isX" and "getX", where "X" is the same in both, or two such getters
          with the same name but different return type, they are not eligible
          getters.
        </item>
        <item>Then, the method returns a CBOR map with each eligible getter's name
          or property name as each key, and with the corresponding value
          returned by that getter as that key's value. Before adding a key-value
          pair to the map, the key's name is adjusted according to the rules
          described in the
          <see cref='T:PeterO.Cbor.PODOptions'/>
           documentation. Note that for security reasons, certain types are not
          supported even if they contain eligible getters.
        </item>
      </list>
      <para><b>REMARK:</b> .NET enumeration (
        <c>Enum</c> ) constants could also have been converted to text strings with
        <c>ToString()</c> , but that method will return multiple names if the given Enum object
        is a combination of Enum objects (e.g. if the object is
        <c>FileAccess.Read | FileAccess.Write</c> ). More generally, if Enums are converted to text strings, constants
        from Enum types with the
        <c>Flags</c> attribute, and constants from the same Enum type that share an
        underlying value, should not be passed to this method.
      </para>
      <para>REMARK: A certain consistency between .NET and Java and between
        FromObject and ToObject are sought for version 4.0. It is also hoped
        that--
      </para>
      <list>
        <item>the ToObject method will support deserializing to objects consisting
          of fields and not getters ("getX()" methods), both in .NET and in
          Java, and
        </item>
        <item>both FromObject and ToObject will be better designed, in version 4.0,
          so that backward-compatible improvements are easier to make.
        </item>
      </list>
    </summary>
    <param name='obj'>An arbitrary object to convert to a CBOR object.
      <para><b>NOTE:</b> For security reasons, whenever possible, an application should not base
        this parameter on user input or other externally supplied data unless
        the application limits this parameter's inputs to types specially
        handled by this method (such as
        <c>int</c> or
        <c>String</c> ) and/or to plain-old-data types (POCO or POJO types) within the
        control of the application. If the plain-old-data type references other
        data types, those types should likewise meet either criterion above.
      </para>
       .
    </param>
    <param name='mapper'>An object containing optional converters to convert objects of certain
      types to CBOR objects.
    </param>
    <param name='options'>An object containing options to control how certain objects are converted
      to CBOR objects.
    </param>
    <returns>A CBOR object corresponding to the given object. Returns CBORObject.Null
      if the object is null.
    </returns>
    <exception cref='T:System.ArgumentNullException'>The parameter
      <paramref name='options'/>
       is null.
    </exception>
  </doc>
  <doc name='M:PeterO.Cbor.CBORObject.FromObject(System.Object,PeterO.Cbor.PODOptions)'>
    <summary>Generates a CBORObject from an arbitrary object. See the overload of this
      method that takes CBORTypeMapper and PODOptions arguments.
    </summary>
    <param name='obj'>The parameter
      <paramref name='obj'/>
       is an arbitrary object.
      <para><b>NOTE:</b> For security reasons, whenever possible, an application should not base
        this parameter on user input or other externally supplied data unless
        the application limits this parameter's inputs to types specially
        handled by this method (such as
        <c>int</c> or
        <c>String</c> ) and/or to plain-old-data types (POCO or POJO types) within the
        control of the application. If the plain-old-data type references other
        data types, those types should likewise meet either criterion above.
      </para>
       .
    </param>
    <param name='options'>An object containing options to control how certain objects are converted
      to CBOR objects.
    </param>
    <returns>A CBOR object corresponding to the given object. Returns CBORObject.Null
      if the object is null.
    </returns>
    <exception cref='T:System.ArgumentNullException'>The parameter
      <paramref name='options'/>
       is null.
    </exception>
  </doc>
  <doc name='M:PeterO.Cbor.CBORObject.FromObject(System.SByte)'>
    <summary>Converts a signed 8-bit integer to a CBOR object.
    </summary>
    <param name='value'>The parameter
      <paramref name='value'/>
       is an 8-bit signed integer.
    </param>
    <returns>A CBORObject object.
    </returns>
  </doc>
  <doc name='M:PeterO.Cbor.CBORObject.FromObject(System.Single)'>
    <summary>Generates a CBOR object from a 32-bit floating-point number.
    </summary>
    <param name='value'>The parameter
      <paramref name='value'/>
       is a 32-bit floating-point number.
    </param>
    <returns>A CBORObject object.
    </returns>
  </doc>
  <doc name='M:PeterO.Cbor.CBORObject.FromObject(System.String)'>
    <summary>Generates a CBOR object from a text string.
    </summary>
    <param name='strValue'>A string value. Can be null.
    </param>
    <returns>A CBOR object representing the string, or CBORObject.Null if stringValue
      is null.
    </returns>
    <exception cref='T:System.ArgumentException'>The string contains an unpaired surrogate code point.
    </exception>
  </doc>
  <doc name='M:PeterO.Cbor.CBORObject.FromObject(System.UInt16)'>
    <summary>Converts a 16-bit unsigned integer to a CBOR object.
    </summary>
    <param name='value'>A 16-bit unsigned integer.
    </param>
    <returns>A CBORObject object.
    </returns>
  </doc>
  <doc name='M:PeterO.Cbor.CBORObject.FromObject(System.UInt32)'>
    <summary>Converts a 32-bit unsigned integer to a CBOR object.
    </summary>
    <param name='value'>A 32-bit unsigned integer.
    </param>
    <returns>A CBORObject object.
    </returns>
  </doc>
  <doc name='M:PeterO.Cbor.CBORObject.FromObject(System.UInt64)'>
    <summary>Converts a 64-bit unsigned integer to a CBOR object.
    </summary>
    <param name='value'>A 64-bit unsigned integer.
    </param>
    <returns>A CBORObject object.
    </returns>
  </doc>
  <doc name='M:PeterO.Cbor.CBORObject.FromObjectAndTag(System.Object,PeterO.BigInteger)'>
    <summary>Generates a CBOR object from an arbitrary object and gives the resulting
      object a tag.
    </summary>
    <param name='valueOb'>An arbitrary object. If the tag number is 2 or 3, this must be a byte
      string whose bytes represent an integer in little-endian byte order, and
      the value of the number is 1 minus the integer's value for tag 3. If the
      tag number is 4 or 5, this must be an array with two elements: the first
      must be an integer representing the exponent, and the second must be an
      integer representing a mantissa.
    </param>
    <param name='bigintTag'>Tag number. The tag number 55799 can be used to mark a "self-described
      CBOR" object. This document does not attempt to list all CBOR tags and
      their meanings. An up-to-date list can be found at the CBOR Tags registry
      maintained by the Internet Assigned Numbers Authority (
      <i>
         iana.org/assignments/cbor-tags
      </i>
       ).
    </param>
    <returns>A CBOR object where the object
      <paramref name='valueOb'/>
       is converted to a CBOR object and given the tag
      <paramref name='bigintTag'/>
       .
    </returns>
    <exception cref='T:System.ArgumentException'>The parameter
      <paramref name='bigintTag'/>
       is less than 0 or greater than 2^64-1, or
      <paramref name='valueOb'/>
       's type is unsupported.
    </exception>
    <exception cref='T:System.ArgumentNullException'>The parameter
      <paramref name='bigintTag'/>
       is null.
    </exception>
  </doc>
  <doc name='M:PeterO.Cbor.CBORObject.FromObjectAndTag(System.Object,PeterO.Numbers.EInteger)'>
    <summary>Generates a CBOR object from an arbitrary object and gives the resulting
      object a tag.
    </summary>
    <param name='valueOb'>An arbitrary object. If the tag number is 2 or 3, this must be a byte
      string whose bytes represent an integer in little-endian byte order, and
      the value of the number is 1 minus the integer's value for tag 3. If the
      tag number is 4 or 5, this must be an array with two elements: the first
      must be an integer representing the exponent, and the second must be an
      integer representing a mantissa.
    </param>
    <param name='bigintTag'>Tag number. The tag number 55799 can be used to mark a "self-described
      CBOR" object. This document does not attempt to list all CBOR tags and
      their meanings. An up-to-date list can be found at the CBOR Tags registry
      maintained by the Internet Assigned Numbers Authority (
      <i>
         iana.org/assignments/cbor-tags
      </i>
       ).
    </param>
    <returns>A CBOR object where the object
      <paramref name='valueOb'/>
       is converted to a CBOR object and given the tag
      <paramref name='bigintTag'/>
       .
    </returns>
    <exception cref='T:System.ArgumentException'>The parameter
      <paramref name='bigintTag'/>
       is less than 0 or greater than 2^64-1, or
      <paramref name='valueOb'/>
       's type is unsupported.
    </exception>
    <exception cref='T:System.ArgumentNullException'>The parameter
      <paramref name='bigintTag'/>
       is null.
    </exception>
  </doc>
  <doc name='M:PeterO.Cbor.CBORObject.FromObjectAndTag(System.Object,System.Int32)'>
    <summary>Generates a CBOR object from an arbitrary object and gives the resulting
      object a tag.
    </summary>
    <param name='valueObValue'>An arbitrary object. If the tag number is 2 or 3, this must be a byte
      string whose bytes represent an integer in little-endian byte order, and
      the value of the number is 1 minus the integer's value for tag 3. If the
      tag number is 4 or 5, this must be an array with two elements: the first
      must be an integer representing the exponent, and the second must be an
      integer representing a mantissa.
    </param>
    <param name='smallTag'>A 32-bit integer that specifies a tag number. The tag number 55799 can be
      used to mark a "self-described CBOR" object. This document does not
      attempt to list all CBOR tags and their meanings. An up-to-date list can
      be found at the CBOR Tags registry maintained by the Internet Assigned
      Numbers Authority (
      <i>
         iana.org/assignments/cbor-tags
      </i>
       ).
    </param>
    <returns>A CBOR object where the object
      <paramref name='valueObValue'/>
       is converted to a CBOR object and given the tag
      <paramref name='smallTag'/>
       .
    </returns>
    <exception cref='T:System.ArgumentException'>The parameter
      <paramref name='smallTag'/>
       is less than 0 or
      <paramref name='valueObValue'/>
       's type is unsupported.
    </exception>
  </doc>
  <doc name='M:PeterO.Cbor.CBORObject.FromObjectAndTag(System.Object,System.UInt64)'>
    <summary>Generates a CBOR object from an arbitrary object and gives the resulting
      object a tag.
    </summary>
    <param name='o'>The parameter
      <paramref name='o'/>
       is an arbitrary object.
    </param>
    <param name='tag'>A 64-bit integer that specifies a tag number. The tag number 55799 can be
      used to mark a "self-described CBOR" object. This document does not
      attempt to list all CBOR tags and their meanings. An up-to-date list can
      be found at the CBOR Tags registry maintained by the Internet Assigned
      Numbers Authority (
      <i>
         iana.org/assignments/cbor-tags
      </i>
       ).
    </param>
    <returns>A CBOR object where the object
      <paramref name='o'/>
       is converted to a CBOR object and given the tag
      <paramref name='tag'/>
       .
    </returns>
  </doc>
  <doc name='M:PeterO.Cbor.CBORObject.FromObject``1(System.Collections.Generic.IEnumerable{``0})'>
    <summary>Generates a CBOR object from an enumerable set of objects.
    </summary>
    <param name='value'>An object that implements the IEnumerable interface. In the .NET version,
      this can be the return value of an iterator or the result of a LINQ query.

    </param>
    <typeparam name='T'>A type convertible to CBORObject.
    </typeparam>
    <returns>A CBOR object where each element of the given enumerable object is
      converted to a CBOR object and copied to a new array, or CBORObject.Null
      if the value is null.
    </returns>
  </doc>
  <doc name='M:PeterO.Cbor.CBORObject.FromObject``1(System.Collections.Generic.IList{``0})'>
    <summary>Generates a CBOR object from a list of objects.
    </summary>
    <param name='value'>An array of CBOR objects. Can be null.
    </param>
    <typeparam name='T'>A type convertible to CBORObject.
    </typeparam>
    <returns>A CBOR object where each element of the given array is converted to a CBOR
      object and copied to a new array, or CBORObject.Null if the value is null.

    </returns>
  </doc>
  <doc name='M:PeterO.Cbor.CBORObject.FromObject``2(System.Collections.Generic.IDictionary{``0,``1})'>
    <summary>Generates a CBOR object from a map of objects.
    </summary>
    <param name='dic'>A map of CBOR objects.
    </param>
    <typeparam name='TKey'>A type convertible to CBORObject; the type of the keys.
    </typeparam>
    <typeparam name='TValue'>A type convertible to CBORObject; the type of the values.
    </typeparam>
    <returns>A CBOR object where each key and value of the given map is converted to a
      CBOR object and copied to a new map, or CBORObject.Null if
      <paramref name='dic'/>
       is null.
    </returns>
  </doc>
  <doc name='M:PeterO.Cbor.CBORObject.FromSimpleValue(System.Int32)'>
    <summary>Creates a CBOR object from a simple value number.
    </summary>
    <param name='simpleValue'>The parameter
      <paramref name='simpleValue'/>
       is a 32-bit signed integer.
    </param>
    <returns>A CBORObject object.
    </returns>
    <exception cref='T:System.ArgumentException'>The parameter
      <paramref name='simpleValue'/>
       is less than 0, greater than 255, or from 24 through 31.
    </exception>
  </doc>
  <doc name='M:PeterO.Cbor.CBORObject.GetAllTags'>
    <summary>Gets a list of all tags, from outermost to innermost.
    </summary>
    <returns>An array of tags, or the empty string if this object is untagged.
    </returns>
  </doc>
  <doc name='M:PeterO.Cbor.CBORObject.GetByteString'>
    <summary>Gets the backing byte array used in this CBOR object, if this object is a
      byte string, without copying the data to a new byte array. Any changes in
      the returned array's contents will be reflected in this CBOR object. Note,
      though, that the array's length can't be changed.
    </summary>
    <returns>The byte array held by this CBOR object.
    </returns>
    <exception cref='T:System.InvalidOperationException'>This object is not a byte string.
    </exception>
  </doc>
  <doc name='M:PeterO.Cbor.CBORObject.GetHashCode'>
    <summary>Calculates the hash code of this object. No application or process IDs are
      used in the hash code calculation.
    </summary>
    <returns>A 32-bit hash code.
    </returns>
  </doc>
  <doc name='M:PeterO.Cbor.CBORObject.GetOrDefault(System.Object,PeterO.Cbor.CBORObject)'>
    <summary>Gets the value of a CBOR object by integer index in this array or by CBOR
      object key in this map, or a default value if that value is not found.
    </summary>
    <param name='key'>An arbitrary object. If this is a CBOR map, this parameter is converted to
      a CBOR object serving as the key to the map or index to the array, and can
      be null. If this is a CBOR array, the key must be an integer 0 or greater
      and less than the size of the array, and may be any object convertible to
      a CBOR integer.
    </param>
    <param name='defaultValue'>A value to return if an item with the given key doesn't exist, or if the
      CBOR object is an array and the key is not an integer 0 or greater and
      less than the size of the array.
    </param>
    <returns>The CBOR object referred to by index or key in this array or map. If this
      is a CBOR map, returns null if an item with the given key doesn't exist.
    </returns>
  </doc>
  <doc name='M:PeterO.Cbor.CBORObject.GetTags'>
    <summary>Gets a list of all tags, from outermost to innermost.
    </summary>
    <returns>An array of tags, or the empty string if this object is untagged.
    </returns>
  </doc>
  <doc name='M:PeterO.Cbor.CBORObject.HasMostOuterTag(PeterO.Numbers.EInteger)'>
    <summary>Returns whether this object has an outermost tag and that tag is of the
      given number.
    </summary>
    <param name='bigTagValue'>The tag number.
    </param>
    <returns><c>true</c> if this object has an outermost tag and that tag is of the given number;
      otherwise,
      <c>false</c> .
    </returns>
    <exception cref='T:System.ArgumentNullException'>The parameter
      <paramref name='bigTagValue'/>
       is null.
    </exception>
    <exception cref='T:System.ArgumentException'>The parameter
      <paramref name='bigTagValue'/>
       is less than 0.
    </exception>
  </doc>
  <doc name='M:PeterO.Cbor.CBORObject.HasMostOuterTag(System.Int32)'>
    <summary>Returns whether this object has an outermost tag and that tag is of the
      given number.
    </summary>
    <param name='tagValue'>The tag number.
    </param>
    <returns><c>true</c> if this object has an outermost tag and that tag is of the given number;
      otherwise,
      <c>false</c> .
    </returns>
    <exception cref='T:System.ArgumentException'>The parameter
      <paramref name='tagValue'/>
       is less than 0.
    </exception>
  </doc>
  <doc name='M:PeterO.Cbor.CBORObject.HasTag(PeterO.BigInteger)'>
    <summary>Returns whether this object has a tag of the given number.
    </summary>
    <param name='bigTagValue'>The tag value to search for.
    </param>
    <returns><c>true</c> if this object has a tag of the given number; otherwise,
      <c>false</c> .
    </returns>
    <exception cref='T:System.ArgumentNullException'>bigTagValue" is null.
    </exception>
    <exception cref='T:System.ArgumentException'>bigTagValue" is less than 0.
    </exception>
  </doc>
  <doc name='M:PeterO.Cbor.CBORObject.HasTag(PeterO.Numbers.EInteger)'>
    <summary>Returns whether this object has a tag of the given number.
    </summary>
    <param name='bigTagValue'>The tag value to search for.
    </param>
    <returns><c>true</c> if this object has a tag of the given number; otherwise,
      <c>false</c> .
    </returns>
    <exception cref='T:System.ArgumentNullException'>The parameter
      <paramref name='bigTagValue'/>
       is null.
    </exception>
    <exception cref='T:System.ArgumentException'>The parameter
      <paramref name='bigTagValue'/>
       is less than 0.
    </exception>
  </doc>
  <doc name='M:PeterO.Cbor.CBORObject.HasTag(System.Int32)'>
    <summary>Returns whether this object has a tag of the given number.
    </summary>
    <param name='tagValue'>The tag value to search for.
    </param>
    <returns><c>true</c> if this object has a tag of the given number; otherwise,
      <c>false</c> .
    </returns>
    <exception cref='T:System.ArgumentException'>The parameter
      <paramref name='tagValue'/>
       is less than 0.
    </exception>
    <exception cref='T:System.ArgumentNullException'>The parameter
      <paramref name='tagValue'/>
       is null.
    </exception>
  </doc>
  <doc name='P:PeterO.Cbor.CBORObject.InnermostTag'>
    <summary>Gets the last defined tag for this CBOR data item, or -1 if the item is
      untagged.
    </summary>
    <value>The last defined tag for this CBOR data item, or -1 if the item is
      untagged.
    </value>
  </doc>
  <doc name='M:PeterO.Cbor.CBORObject.Insert(System.Int32,System.Object)'>
    <summary>Inserts an object at the specified position in this CBOR array.
    </summary>
    <param name='index'>Zero-based index to insert at.
    </param>
    <param name='valueOb'>An object representing the value, which will be converted to a CBORObject.
      Can be null, in which case this value is converted to CBORObject.Null.
    </param>
    <returns>This instance.
    </returns>
    <exception cref='T:System.InvalidOperationException'>This object is not an array.
    </exception>
    <exception cref='T:System.ArgumentException'>The parameter
      <paramref name='valueOb'/>
       has an unsupported type; or
      <paramref name='index'/>
       is not a valid index into this array.
    </exception>
  </doc>
  <doc name='P:PeterO.Cbor.CBORObject.IsFalse'>
    <summary>Gets a value indicating whether this value is a CBOR false value.
    </summary>
    <value><c>true</c> If this value is a CBOR false value; otherwise, .
      <c>false</c> .
    </value>
  </doc>
  <doc name='P:PeterO.Cbor.CBORObject.IsFinite'>
    <summary>Gets a value indicating whether this CBOR object represents a finite
      number.
    </summary>
    <value><c>true</c> If this CBOR object represents a finite number; otherwise, .
      <c>false</c> .
    </value>
  </doc>
  <doc name='M:PeterO.Cbor.CBORObject.IsInfinity'>
    <summary>Gets a value indicating whether this CBOR object represents infinity.
    </summary>
    <returns><c>true</c> if this CBOR object represents infinity; otherwise,
      <c>false</c> .
    </returns>
  </doc>
  <doc name='P:PeterO.Cbor.CBORObject.IsIntegral'>
    <summary>Gets a value indicating whether this object represents an integer number,
      that is, a number without a fractional part. Infinity and not-a-number are
      not considered integers.
    </summary>
    <value><c>true</c> If this object represents an integer number, that is, a number without a
      fractional part; otherwise, .
      <c>false</c> .
    </value>
  </doc>
  <doc name='M:PeterO.Cbor.CBORObject.IsNaN'>
    <summary>Gets a value indicating whether this CBOR object represents a not-a-number
      value (as opposed to whether this object's type is not a number type).
    </summary>
    <returns><c>true</c> if this CBOR object represents a not-a-number value (as opposed to
      whether this object's type is not a number type); otherwise,
      <c>false</c> .
    </returns>
  </doc>
  <doc name='P:PeterO.Cbor.CBORObject.IsNegative'>
    <summary>Gets a value indicating whether this object is a negative number.
    </summary>
    <value><c>true</c> If this object is a negative number; otherwise, .
      <c>false</c> .
    </value>
  </doc>
  <doc name='M:PeterO.Cbor.CBORObject.IsNegativeInfinity'>
    <summary>Gets a value indicating whether this CBOR object represents negative
      infinity.
    </summary>
    <returns><c>true</c> if this CBOR object represents negative infinity; otherwise,
      <c>false</c> .
    </returns>
  </doc>
  <doc name='P:PeterO.Cbor.CBORObject.IsNull'>
    <summary>Gets a value indicating whether this value is a CBOR null value.
    </summary>
    <value><c>true</c> If this value is a CBOR null value; otherwise, .
      <c>false</c> .
    </value>
  </doc>
  <doc name='M:PeterO.Cbor.CBORObject.IsPositiveInfinity'>
    <summary>Gets a value indicating whether this CBOR object represents positive
      infinity.
    </summary>
    <returns><c>true</c> if this CBOR object represents positive infinity; otherwise,
      <c>false</c> .
    </returns>
  </doc>
  <doc name='P:PeterO.Cbor.CBORObject.IsTagged'>
    <summary>Gets a value indicating whether this data item has at least one tag.
    </summary>
    <value><c>true</c> If this data item has at least one tag; otherwise, .
      <c>false</c> .
    </value>
  </doc>
  <doc name='P:PeterO.Cbor.CBORObject.IsTrue'>
    <summary>Gets a value indicating whether this value is a CBOR true value.
    </summary>
    <value><c>true</c> If this value is a CBOR true value; otherwise, .
      <c>false</c> .
    </value>
  </doc>
  <doc name='P:PeterO.Cbor.CBORObject.IsUndefined'>
    <summary>Gets a value indicating whether this value is a CBOR undefined value.
    </summary>
    <value><c>true</c> If this value is a CBOR undefined value; otherwise, .
      <c>false</c> .
    </value>
  </doc>
  <doc name='P:PeterO.Cbor.CBORObject.IsZero'>
    <summary>Gets a value indicating whether this object's value equals 0.
    </summary>
    <value><c>true</c> If this object&apos;s value equals 0; otherwise, .
      <c>false</c> .
    </value>
  </doc>
  <doc name='P:PeterO.Cbor.CBORObject.Item(PeterO.Cbor.CBORObject)'>
    <summary>Gets the value of a CBOR object by integer index in this array or by CBOR
      object key in this map.
    </summary>
    <param name='key'>A CBOR object serving as the key to the map or index to the array. If this
      is a CBOR array, the key must be an integer 0 or greater and less than the
      size of the array.
    </param>
    <returns>The CBOR object referred to by index or key in this array or map. If this
      is a CBOR map, returns null if an item with the given key doesn't exist.
    </returns>
    <exception cref='T:System.ArgumentNullException'>The key is null (as opposed to CBORObject.Null); or the set method is
      called and the value is null.
    </exception>
    <exception cref='T:System.ArgumentException'>This CBOR object is an array and the key is not an integer 0 or greater
      and less than the size of the array.
    </exception>
    <exception cref='T:System.InvalidOperationException'>This object is not a map or an array.
    </exception>
  </doc>
  <doc name='P:PeterO.Cbor.CBORObject.Item(System.Int32)'>
    <summary>Gets the value of a CBOR object by integer index in this array or by
      integer key in this map.
    </summary>
    <param name='index'>Zero-based index of the element, or the integer key to this map. (If this
      is a map, the given index can be any 32-bit signed integer, even a
      negative one.).
    </param>
    <returns>The CBOR object referred to by index or key in this array or map. If this
      is a CBOR map, returns null if an item with the given key doesn't exist.
    </returns>
    <exception cref='T:System.InvalidOperationException'>This object is not an array or map.
    </exception>
    <exception cref='T:System.ArgumentException'>This object is an array and the index is less than 0 or at least the size
      of the array.
    </exception>
    <exception cref='T:System.ArgumentNullException'>The parameter "value" is null (as opposed to CBORObject.Null).
    </exception>
  </doc>
  <doc name='P:PeterO.Cbor.CBORObject.Item(System.String)'>
    <summary>Gets the value of a CBOR object in this map, using a string as the key.
    </summary>
    <param name='key'>A key that points to the desired value.
    </param>
    <returns>The CBOR object referred to by key in this map. Returns
      <c>null</c> if an item with the given key doesn't exist.
    </returns>
    <exception cref='T:System.ArgumentNullException'>The key is null.
    </exception>
    <exception cref='T:System.InvalidOperationException'>This object is not a map.
    </exception>
  </doc>
  <doc name='P:PeterO.Cbor.CBORObject.Keys'>
    <summary>Gets a collection of the keys of this CBOR object in an undefined order.
    </summary>
    <value>A collection of the keys of this CBOR object.
    </value>
    <exception cref='T:System.InvalidOperationException'>This object is not a map.
    </exception>
  </doc>
  <doc name='P:PeterO.Cbor.CBORObject.MostInnerTag'>
    <summary>Gets the last defined tag for this CBOR data item, or -1 if the item is
      untagged.
    </summary>
    <value>The last defined tag for this CBOR data item, or -1 if the item is
      untagged.
    </value>
  </doc>
  <doc name='P:PeterO.Cbor.CBORObject.MostOuterTag'>
    <summary>Gets the outermost tag for this CBOR data item, or -1 if the item is
      untagged.
    </summary>
    <value>The outermost tag for this CBOR data item, or -1 if the item is untagged.
    </value>
  </doc>
  <doc name='M:PeterO.Cbor.CBORObject.Multiply(PeterO.Cbor.CBORObject,PeterO.Cbor.CBORObject)'>
    <summary>Multiplies two CBOR numbers.
    </summary>
    <param name='first'>The parameter
      <paramref name='first'/>
       is a CBOR object.
    </param>
    <param name='second'>The parameter
      <paramref name='second'/>
       is a CBOR object.
    </param>
    <returns>The product of the two numbers.
    </returns>
    <exception cref='T:System.ArgumentException'>Either or both operands are not numbers (as opposed to Not-a-Number, NaN).
    </exception>
  </doc>
  <doc name='F:PeterO.Cbor.CBORObject.NaN'>
    <summary>A not-a-number value.
    </summary>
  </doc>
  <doc name='M:PeterO.Cbor.CBORObject.Negate'>
    <summary>Gets this object's value with the sign reversed.
    </summary>
    <returns>The reversed-sign form of this number.
    </returns>
    <exception cref='T:System.InvalidOperationException'>This object's type is not a number type.
    </exception>
  </doc>
  <doc name='F:PeterO.Cbor.CBORObject.NegativeInfinity'>
    <summary>The value negative infinity.
    </summary>
  </doc>
  <doc name='M:PeterO.Cbor.CBORObject.NewArray'>
    <summary>Creates a new empty CBOR array.
    </summary>
    <returns>A new CBOR array.
    </returns>
  </doc>
  <doc name='M:PeterO.Cbor.CBORObject.NewMap'>
    <summary>Creates a new empty CBOR map.
    </summary>
    <returns>A new CBOR map.
    </returns>
  </doc>
  <doc name='F:PeterO.Cbor.CBORObject.Null'>
    <summary>Represents the value null.
    </summary>
  </doc>
  <doc name='P:PeterO.Cbor.CBORObject.OutermostTag'>
    <summary>Gets the outermost tag for this CBOR data item, or -1 if the item is
      untagged.
    </summary>
    <value>The outermost tag for this CBOR data item, or -1 if the item is untagged.
    </value>
  </doc>
  <doc name='F:PeterO.Cbor.CBORObject.PositiveInfinity'>
    <summary>The value positive infinity.
    </summary>
  </doc>
  <doc name='M:PeterO.Cbor.CBORObject.Read(System.IO.Stream)'>
    <summary><para>Reads an object in CBOR format from a data stream. This method will read
        from the stream until the end of the CBOR object is reached or an error
        occurs, whichever happens first.
      </para>
    </summary>
    <param name='stream'>A readable data stream.
    </param>
    <returns>A CBOR object that was read.
    </returns>
    <exception cref='T:System.ArgumentNullException'>The parameter
      <paramref name='stream'/>
       is null.
    </exception>
    <exception cref='T:PeterO.Cbor.CBORException'>There was an error in reading or parsing the data.
    </exception>
  </doc>
  <doc name='M:PeterO.Cbor.CBORObject.Read(System.IO.Stream,PeterO.Cbor.CBOREncodeOptions)'>
    <summary>Reads an object in CBOR format from a data stream, using the specified
      options to control the decoding process. This method will read from the
      stream until the end of the CBOR object is reached or an error occurs,
      whichever happens first.
    </summary>
    <param name='stream'>A readable data stream.
    </param>
    <param name='options'>The parameter
      <paramref name='options'/>
       is a CBOREncodeOptions object.
    </param>
    <returns>A CBOR object that was read.
    </returns>
    <exception cref='T:System.ArgumentNullException'>The parameter
      <paramref name='stream'/>
       is null.
    </exception>
    <exception cref='T:PeterO.Cbor.CBORException'>There was an error in reading or parsing the data.
    </exception>
  </doc>
  <doc name='M:PeterO.Cbor.CBORObject.ReadJSON(System.IO.Stream)'>
    <summary>Generates a CBOR object from a data stream in JavaScript Object Notation
      (JSON) format. The JSON stream may begin with a byte-order mark (U+FEFF).
      Since version 2.0, the JSON stream can be in UTF-8, UTF-16, or UTF-32
      encoding; the encoding is detected by assuming that the first character
      read must be a byte-order mark or a nonzero basic character (U+0001 to
      U+007F). (In previous versions, only UTF-8 was allowed.)
      <para>If a JSON object has the same key, only the last given value will be
        used for each duplicated key.
      </para>
    </summary>
    <param name='stream'>A readable data stream. The sequence of bytes read from the data stream
      must contain a single JSON object and not multiple objects.
    </param>
    <returns>A CBORObject object.
    </returns>
    <exception cref='T:System.ArgumentNullException'>The parameter
      <paramref name='stream'/>
       is null.
    </exception>
    <exception cref='T:System.IO.IOException'>An I/O error occurred.
    </exception>
    <exception cref='T:PeterO.Cbor.CBORException'>The data stream contains invalid encoding or is not in JSON format.
    </exception>
  </doc>
  <doc name='M:PeterO.Cbor.CBORObject.ReadJSON(System.IO.Stream,PeterO.Cbor.CBOREncodeOptions)'>
    <summary>Generates a CBOR object from a data stream in JavaScript Object Notation
      (JSON) format, using the specified options to control the decoding
      process. The JSON stream may begin with a byte-order mark (U+FEFF). Since
      version 2.0, the JSON stream can be in UTF-8, UTF-16, or UTF-32 encoding;
      the encoding is detected by assuming that the first character read must be
      a byte-order mark or a nonzero basic character (U+0001 to U+007F). (In
      previous versions, only UTF-8 was allowed.)
      <para>By default, if a JSON object has the same key, only the last given value
        will be used for each duplicated key.
      </para>
    </summary>
    <param name='stream'>A readable data stream. The sequence of bytes read from the data stream
      must contain a single JSON object and not multiple objects.
    </param>
    <param name='options'>The parameter
      <paramref name='options'/>
       is a CBOREncodeOptions object.
    </param>
    <returns>A CBORObject object.
    </returns>
    <exception cref='T:System.ArgumentNullException'>The parameter
      <paramref name='stream'/>
       is null.
    </exception>
    <exception cref='T:System.IO.IOException'>An I/O error occurred.
    </exception>
    <exception cref='T:PeterO.Cbor.CBORException'>The data stream contains invalid encoding or is not in JSON format.
    </exception>
  </doc>
  <doc name='M:PeterO.Cbor.CBORObject.Remainder(PeterO.Cbor.CBORObject,PeterO.Cbor.CBORObject)'>
    <summary>Finds the remainder that results when a CBORObject object is divided by
      the value of a CBORObject object.
    </summary>
    <param name='first'>The parameter
      <paramref name='first'/>
       is a CBOR object.
    </param>
    <param name='second'>The parameter
      <paramref name='second'/>
       is a CBOR object.
    </param>
    <returns>The remainder of the two numbers.
    </returns>
  </doc>
  <doc name='M:PeterO.Cbor.CBORObject.Remove(PeterO.Cbor.CBORObject)'>
    <summary>If this object is an array, removes the first instance of the specified
      item from the array. If this object is a map, removes the item with the
      given key from the map.
    </summary>
    <param name='obj'>The item or key to remove.
    </param>
    <returns><c>true</c> if the item was removed; otherwise,
      <c>false</c> .
    </returns>
    <exception cref='T:System.ArgumentNullException'>The parameter
      <paramref name='obj'/>
       is null (as opposed to CBORObject.Null).
    </exception>
    <exception cref='T:System.InvalidOperationException'>The object is not an array or map.
    </exception>
  </doc>
  <doc name='M:PeterO.Cbor.CBORObject.Remove(System.Object)'>
    <summary>If this object is an array, removes the first instance of the specified
      item (once converted to a CBOR object) from the array. If this object is a
      map, removes the item with the given key (once converted to a CBOR object)
      from the map.
    </summary>
    <param name='obj'>The item or key (once converted to a CBOR object) to remove.
    </param>
    <returns><c>true</c> if the item was removed; otherwise,
      <c>false</c> .
    </returns>
    <exception cref='T:System.ArgumentNullException'>The parameter
      <paramref name='obj'/>
       is null (as opposed to CBORObject.Null).
    </exception>
    <exception cref='T:System.InvalidOperationException'>The object is not an array or map.
    </exception>
  </doc>
  <doc name='M:PeterO.Cbor.CBORObject.RemoveAt(System.Int32)'>
    <summary>Removes the item at the given index of this CBOR array.
    </summary>
    <param name='index'>The index, starting at 0, of the item to remove.
    </param>
    <returns>Returns "true" if the object was removed. Returns "false" if the given
      index is less than 0, or is at least as high as the number of items in the
      array.
    </returns>
    <exception cref='T:System.InvalidOperationException'>This object is not a CBOR array.
    </exception>
  </doc>
  <doc name='M:PeterO.Cbor.CBORObject.Set(System.Object,System.Object)'>
    <summary>Maps an object to a key in this CBOR map, or adds the value if the key
      doesn't exist. If this is a CBOR array, instead sets the value at the
      given index to the given value.
    </summary>
    <param name='key'>If this instance is a CBOR map, this parameter is an object representing
      the key, which will be converted to a CBORObject; in this case, this
      parameter can be null, in which case this value is converted to
      CBORObject.Null. If this instance is a CBOR array, this parameter must be
      a 32-bit signed integer (
      <c>int</c> ) identifying the index (starting from 0) of the item to set in the
      array.
    </param>
    <param name='valueOb'>An object representing the value, which will be converted to a CBORObject.
      Can be null, in which case this value is converted to CBORObject.Null.
    </param>
    <returns>This instance.
    </returns>
    <exception cref='T:System.InvalidOperationException'>This object is not a map or an array.
    </exception>
    <exception cref='T:System.ArgumentException'>The parameter
      <paramref name='key'/>
       or
      <paramref name='valueOb'/>
       has an unsupported type, or this instance is a CBOR array and
      <paramref name='key'/>
       is less than 0, is the size of this array or greater, or is not a 32-bit
      signed integer (
      <c>int</c> ).
    </exception>
  </doc>
  <doc name='P:PeterO.Cbor.CBORObject.Sign'>
    <summary>Gets this value's sign: -1 if negative; 1 if positive; 0 if zero.
    </summary>
    <value>This value&#x27;s sign: -1 if negative; 1 if positive; 0 if zero.
    </value>
    <exception cref='T:System.InvalidOperationException'>This object's type is not a number type, including the special
      not-a-number value (NaN).
    </exception>
  </doc>
  <doc name='P:PeterO.Cbor.CBORObject.SimpleValue'>
    <summary>Gets the simple value ID of this object, or -1 if this object is not a
      simple value (including if the value is a floating-point number).
    </summary>
    <value>The simple value ID of this object, or -1 if this object is not a simple
      value (including if the value is a floating-point number).
    </value>
  </doc>
  <doc name='M:PeterO.Cbor.CBORObject.Subtract(PeterO.Cbor.CBORObject,PeterO.Cbor.CBORObject)'>
    <summary>Finds the difference between two CBOR number objects.
    </summary>
    <param name='first'>The parameter
      <paramref name='first'/>
       is a CBOR object.
    </param>
    <param name='second'>The parameter
      <paramref name='second'/>
       is a CBOR object.
    </param>
    <returns>The difference of the two objects.
    </returns>
    <exception cref='T:System.ArgumentException'>Either or both operands are not numbers (as opposed to Not-a-Number, NaN).
    </exception>
  </doc>
  <doc name='M:PeterO.Cbor.CBORObject.ToJSONString'>
    <summary>Converts this object to a string in JavaScript Object Notation (JSON)
      format. See the overload to JSONString taking a JSONOptions argument for
      further information.
      <para>If the CBOR object contains CBOR maps, or is a CBOR map itself, the keys
        to the map are written out to the JSON string in an undefined order. Map
        keys other than untagged text strings are converted to JSON strings
        before writing them out (for example,
        <c>22("Test")</c> is converted to
        <c>"Test"</c> and
        <c>true</c> is converted to
        <c>"true"</c> ). If, after such conversion, two or more map keys are identical, this
        method throws a CBORException. The example code given in
        <see cref='M:PeterO.Cbor.CBORObject.ToJSONString(PeterO.Cbor.JSONOptions)'/>
         can be used to write out certain keys of a CBOR map in a given order to
        a JSON string.
      </para>
    </summary>
    <returns>A text string.
    </returns>
  </doc>
  <doc name='M:PeterO.Cbor.CBORObject.ToJSONString(PeterO.Cbor.JSONOptions)'>
    <summary>Converts this object to a string in JavaScript Object Notation (JSON)
      format, using the specified options to control the encoding process. This
      function works not only with arrays and maps, but also integers, strings,
      byte arrays, and other JSON data types. Notes:
      <list type=''>
        <item>If this object contains maps with non-string keys, the keys are
          converted to JSON strings before writing the map as a JSON string.
        </item>
        <item>If the CBOR object contains CBOR maps, or is a CBOR map itself, the
          keys to the map are written out to the JSON string in an undefined
          order. Map keys other than untagged text strings are converted to JSON
          strings before writing them out (for example,
          <c>22("Test")</c> is converted to
          <c>"Test"</c> and
          <c>true</c> is converted to
          <c>"true"</c> ///). If, after such conversion, two or more map keys are identical,
          this method throws a CBORException.
        </item>
        <item>If a number in the form of an arbitrary-precision binary float has a
          very high binary exponent, it will be converted to a double before
          being converted to a JSON string. (The resulting double could overflow
          to infinity, in which case the arbitrary-precision binary float is
          converted to null.)
        </item>
        <item>The string will not begin with a byte-order mark (U+FEFF); RFC 8259
          (the JSON specification) forbids placing a byte-order mark at the
          beginning of a JSON string.
        </item>
        <item>Byte strings are converted to Base64 URL without whitespace or padding
          by default (see section 4.1 of RFC 7049). A byte string will instead
          be converted to traditional base64 without whitespace and with padding
          if it has tag 22, or base16 for tag 23. (To create a CBOR object with
          a given tag, call the
          <c>CBORObject.FromObjectAndTag</c> method and pass the CBOR object and the desired tag number to that
          method.)
        </item>
        <item>Rational numbers will be converted to their exact form, if possible,
          otherwise to a high-precision approximation. (The resulting
          approximation could overflow to infinity, in which case the rational
          number is converted to null.)
        </item>
        <item>Simple values other than true and false will be converted to null.
          (This doesn't include floating-point numbers.)
        </item>
        <item>Infinity and not-a-number will be converted to null.
        </item>
      </list>
      <para>The example code given below (originally written in C# for the .NET
        version) can be used to write out certain keys of a CBOR map in a given
        order to a JSON string.
      </para>
      <code>/* Generates a JSON string of 'mapObj' whose keys are in the order given
        in 'keys' . Only keys found in 'keys' will be written if they exist in
        'mapObj'. */ private static string KeysToJSONMap&#x28;CBORObject mapObj,
        IList&lt;CBORObject&gt; keys&#x29;&#x7b; if (mapObj == null) { throw new
        ArgumentNullException&#x29;nameof(mapObj));} if (keys == null) { throw
        new ArgumentNullException&#x29;nameof(keys));} if (obj.Type !=
        CBORType.Map) { throw new ArgumentException("'obj' is not a map."); }
        StringBuilder builder = new StringBuilder(); var first = true;
        builder.Append("{"); for (CBORObject key in keys) { if
        (mapObj.ContainsKey(key)) { if (!first) {builder.Append(", ");} var
        keyString=(key.CBORType == CBORType.String) ? key.AsString() :
        key.ToJSONString(); builder.Append(CBORObject.FromObject(keyString)
        .ToJSONString()) .Append(":").Append(mapObj[key].ToJSONString());
        first=false; } } return builder.Append("}").ToString(); }</code> .
    </summary>
    <param name='options'>An object containing the options to control writing the CBOR object to
      JSON.
    </param>
    <returns>A text string containing the converted object.
    </returns>
    <exception cref='T:System.ArgumentNullException'>The parameter
      <paramref name='options'/>
       is null.
    </exception>
  </doc>
  <doc name='M:PeterO.Cbor.CBORObject.ToObject(System.Type)'>
    <summary>Converts this CBOR object to an object of an arbitrary type. See the
      documentation for the overload of this method taking a CBORTypeMapper
      parameter for more information. This method doesn't use a CBORTypeMapper
      parameter to restrict which data types are eligible for Plain-Old-Data
      serialization.
    </summary>
    <param name='t'>The type, class, or interface that this method's return value will belong
      to. To express a generic type in Java, see the example.
      <b>Note:</b> For security reasons, an application should not base this parameter on
      user input or other externally supplied data. Whenever possible, this
      parameter should be either a type specially handled by this method (such
      as
      <c>int</c> or
      <c>String</c> ) or a plain-old-data type (POCO or POJO type) within the control of the
      application. If the plain-old-data type references other data types, those
      types should likewise meet either criterion above.
    </param>
    <returns>The converted object.
    </returns>
    <exception cref='T:System.CBORException'>The given type
      <paramref name='t'/>
       , or this object's CBOR type, is not supported, or the given object's
      nesting is too deep, or another error occurred when serializing the
      object.
    </exception>
    <exception cref='T:System.ArgumentNullException'>The parameter
      <paramref name='t'/>
       is null.
    </exception>
    <example><para>Java offers no easy way to express a generic type, at least none as easy
        as C#'s
        <c>typeof</c> operator. The following example, written in Java, is a way to specify
        that the return value will be an ArrayList of String objects.
      </para>
      <code>Type arrayListString = new ParameterizedType(){ public Type[]
        getActualTypeArguments(){ /* Contains one type parameter, String */
        return new Type[]{ String.class }; } public Type getRawType(){ /* Raw
        type is ArrayList */ return ArrayList.class; } public Type
        getOwnerType(){ return null; } }; ArrayList&lt;String&gt; array =
        (ArrayList&lt;String&gt;) cborArray.ToObject(arrayListString);</code> <para>By comparison, the C# version is much shorter.
      </para>
      <code>var&#x20;array = (List&lt;String&gt;)cborArray.ToObject(
        typeof&#x28;List&lt;String&gt;));</code> .
    </example>
  </doc>
  <doc name='M:PeterO.Cbor.CBORObject.ToObject(System.Type,PeterO.Cbor.CBORTypeMapper)'>
    <summary>Converts this CBOR object to an object of an arbitrary type. See the
      documentation for the overload of this method taking a CBORTypeMapper and
      PODOptions parameters parameters for more information.
    </summary>
    <param name='t'>The type, class, or interface that this method's return value will belong
      to. To express a generic type in Java, see the example.
      <b>Note:</b> For security reasons, an application should not base this parameter on
      user input or other externally supplied data. Whenever possible, this
      parameter should be either a type specially handled by this method (such
      as
      <c>int</c> or
      <c>String</c> ) or a plain-old-data type (POCO or POJO type) within the control of the
      application. If the plain-old-data type references other data types, those
      types should likewise meet either criterion above.
    </param>
    <param name='mapper'>This parameter controls which data types are eligible for Plain-Old-Data
      deserialization and includes custom converters from CBOR objects to
      certain data types.
    </param>
    <returns>The converted object.
    </returns>
    <exception cref='T:System.CBORException'>The given type
      <paramref name='t'/>
       , or this object's CBOR type, is not supported, or the given object's
      nesting is too deep, or another error occurred when serializing the
      object.
    </exception>
    <exception cref='T:System.ArgumentNullException'>The parameter
      <paramref name='t'/>
       is null.
    </exception>
  </doc>
  <doc name='M:PeterO.Cbor.CBORObject.ToObject(System.Type,PeterO.Cbor.CBORTypeMapper,PeterO.Cbor.PODOptions)'>
    <summary><para>Converts this CBOR object to an object of an arbitrary type. The
        following cases are checked in the logical order given (rather than the
        strict order in which they are implemented by this library):
      </para>
      <list>
        <item>If the type is
          <c>CBORObject</c> , return this object.
        </item>
        <item>If the given object is
          <c>CBORObject.Null</c> (with or without tags), returns
          <c>null</c> .
        </item>
        <item>If the object is of a type corresponding to a type converter mentioned
          in the
          <paramref name='mapper'/>
           parameter, that converter will be used to convert the CBOR object to
          an object of the given type. Type converters can be used to override
          the default conversion behavior of almost any object.
        </item>
        <item>If the type is
          <c>object</c> , return this object.
        </item>
        <item>If the type is
          <c>char</c> , converts single-character CBOR text strings and CBOR integers from
          0 through 65535 to a
          <c>char</c> object and returns that
          <c>char</c> object.
        </item>
        <item>If the type is
          <c>bool</c> (
          <c>boolean</c> in Java), returns the result of AsBoolean.
        </item>
        <item>If the type is a primitive integer type (
          <c>byte</c> ,
          <c>int</c> ,
          <c>short</c> ,
          <c>long</c> , as well as
          <c>sbyte</c> ,
          <c>ushort</c> ,
          <c>uint</c> , and
          <c>ulong</c> in .NET) or a primitive floating-point type (
          <c>float</c> ,
          <c>double</c> , as well as
          <c>decimal</c> in .NET), returns the result of the corresponding As* method.
        </item>
        <item>If the type is
          <c>String</c> , returns the result of AsString.
        </item>
        <item>If the type is
          <c>EDecimal</c> ,
          <c>EFloat</c> ,
          <c>EInteger</c> , or
          <c>ERational</c> in the
          <a href='https://www.nuget.org/packages/PeterO.Numbers'>
            <c>PeterO.Numbers</c> </a>
           library (in .NET) or the
          <a href='https://github.com/peteroupc/numbers-java'>
            <c>com.github.peteroupc/numbers</c> </a>
           artifact (in Java), returns the result of the corresponding As*
          method.
        </item>
        <item>In the .NET version, if the type is a nullable (e.g.,
          <c>Nullable&lt;int&gt;</c> or
          <c>int?</c> , returns
          <c>null</c> if this CBOR object is null, or this object's value converted to the
          nullable's underlying type (e.g.,
          <c>int</c> ).
        </item>
        <item>If the type is an enumeration (
          <c>Enum</c> ) type this CBOR object is a text string or an integer, returns the
          appropriate enumerated constant. (For example, if
          <c>MyEnum</c> includes an entry for
          <c>MyValue</c> , this method will return
          <c>MyEnum.MyValue</c> if the CBOR object represents
          <c>"MyValue"</c> or the underlying value for
          <c>MyEnum.MyValue</c> .)
          <b>Note:</b> If an integer is converted to a .NET Enum constant, and that integer
          is shared by more than one constant of the same type, it is undefined
          which constant from among them is returned. (For example, if
          <c>MyEnum.Zero = 0</c> and
          <c>MyEnum.Null = 0</c> , converting 0 to
          <c>MyEnum</c> may return either
          <c>MyEnum.Zero</c> or
          <c>MyEnum.Null</c> .) As a result, .NET Enum types with constants that share an
          underlying value should not be passed to this method.
        </item>
        <item>If the type is
          <c>byte[]</c> (a one-dimensional byte array) and this CBOR object is a byte string,
          returns a byte array which this CBOR byte string's data will be copied
          to. (This method can't be used to encode CBOR data to a byte array;
          for that, use the EncodeToBytes method instead.)
        </item>
        <item>If the type is a one-dimensional or multidimensional array type and
          this CBOR object is an array, returns an array containing the items in
          this CBOR object.
        </item>
        <item>If the type is List or the generic or non-generic IList, ICollection,
          or IEnumerable, (or ArrayList, List, Collection, or Iterable in Java),
          and if this CBOR object is an array, returns an object conforming to
          the type, class, or interface passed to this method, where the object
          will contain all items in this CBOR array.
        </item>
        <item>If the type is Dictionary or the generic or non-generic IDictionary
          (or HashMap or Map in Java), and if this CBOR object is a map, returns
          an object conforming to the type, class, or interface passed to this
          method, where the object will contain all keys and values in this CBOR
          map.
        </item>
        <item>If the type is an enumeration constant ("enum"), and this CBOR object
          is an integer or text string, returns the enumeration constant with
          the given number or name, respectively. (Enumeration constants made up
          of multiple enumeration constants, as allowed by .NET, can only be
          matched by number this way.)
        </item>
        <item>If the type is
          <c>DateTime</c> (or
          <c>Date</c> in Java) , returns a date/time object if the CBOR object's outermost
          tag is 0 or 1. For tag 1, this method treats the CBOR object as a
          number of seconds since the start of 1970, which is based on the POSIX
          definition of "seconds since the Epoch", a definition that does not
          count leap seconds. In this method, this number of seconds assumes the
          use of a proleptic Gregorian calendar, in which the rules regarding
          the number of days in each month and which years are leap years are
          the same for all years as they were in 1970 (including without regard
          to transitions from other calendars to the Gregorian). For tag 1, CBOR
          objects that express infinity or not-a-number (NaN) are treated as
          invalid by this method.
        </item>
        <item>If the type is
          <c>Uri</c> (or
          <c>URI</c> in Java), returns a URI object if possible.
        </item>
        <item>If the type is
          <c>Guid</c> (or
          <c>UUID</c> in Java), returns a UUID object if possible.
        </item>
        <item>Plain-Old-Data deserialization: If the object is a type not specially
          handled above, the type includes a zero-argument constructor (default
          or not), this CBOR object is a CBOR map, and the "mapper" parameter
          allows this type to be eligible for Plain-Old-Data deserialization,
          then this method checks the given type for eligible setters as
          follows:
        </item>
        <item>(*) In the .NET version, eligible setters are the public, nonstatic
          setters of properties with a public, nonstatic getter. If a class has
          two properties of the form "X" and "IsX", where "X" is any name, or
          has multiple properties with the same name, those properties are
          ignored.
        </item>
        <item>(*) In the Java version, eligible setters are public, nonstatic
          methods starting with "set" followed by a character other than a basic
          digit or lower-case letter, that is, other than "a" to "z" or "0" to
          "9", that take one parameter. The class containing an eligible setter
          must have a public, nonstatic method with the same name, but starting
          with "get" or "is" rather than "set", that takes no parameters and
          does not return void. (For example, if a class has "public
          setValue(String)" and "public getValue()", "setValue" is an eligible
          setter. However, "setValue()" and "setValue(String, int)" are not
          eligible setters.) If a class has two or more otherwise eligible
          setters with the same name, but different parameter type, they are not
          eligible setters.
        </item>
        <item>Then, the method creates an object of the given type and invokes each
          eligible setter with the corresponding value in the CBOR map, if any.
          Key names in the map are matched to eligible setters according to the
          rules described in the
          <see cref='T:PeterO.Cbor.PODOptions'/>
           documentation. Note that for security reasons, certain types are not
          supported even if they contain eligible setters.
        </item>
      </list>
      <para>REMARK: A certain consistency between .NET and Java and between
        FromObject and ToObject are sought for version 4.0. It is also hoped
        that--
      </para>
      <list>
        <item>the ToObject method will support deserializing to objects consisting
          of fields and not getters ("getX()" methods), both in .NET and in
          Java, and
        </item>
        <item>both FromObject and ToObject will be better designed, in version 4.0,
          so that backward-compatible improvements are easier to make.
        </item>
      </list>
    </summary>
    <param name='t'>The type, class, or interface that this method's return value will belong
      to. To express a generic type in Java, see the example.
      <b>Note:</b> For security reasons, an application should not base this parameter on
      user input or other externally supplied data. Whenever possible, this
      parameter should be either a type specially handled by this method (such
      as
      <c>int</c> or
      <c>String</c> ) or a plain-old-data type (POCO or POJO type) within the control of the
      application. If the plain-old-data type references other data types, those
      types should likewise meet either criterion above.
    </param>
    <param name='mapper'>This parameter controls which data types are eligible for Plain-Old-Data
      deserialization and includes custom converters from CBOR objects to
      certain data types.
    </param>
    <param name='options'>Specifies options for controlling deserialization of CBOR objects.
    </param>
    <returns>The converted object.
    </returns>
    <exception cref='T:System.CBORException'>The given type
      <paramref name='t'/>
       , or this object's CBOR type, is not supported, or the given object's
      nesting is too deep, or another error occurred when serializing the
      object.
    </exception>
    <exception cref='T:System.ArgumentNullException'>The parameter
      <paramref name='t'/>
       is null.
    </exception>
    <example><para>Java offers no easy way to express a generic type, at least none as easy
        as C#'s
        <c>typeof</c> operator. The following example, written in Java, is a way to specify
        that the return value will be an ArrayList of String objects.
      </para>
      <code>Type arrayListString = new ParameterizedType() { public Type[]
        getActualTypeArguments() { // Contains one type parameter, String return
        new Type[] { String.class }; } public Type getRawType() { /* Raw type is
        ArrayList */ return ArrayList.class; } public Type getOwnerType() {
        return null; } }; ArrayList&lt;String&gt; array =
        (ArrayList&lt;String&gt;) cborArray.ToObject(arrayListString);</code> <para>By comparison, the C# version is much shorter.
      </para>
      <code>var&#x20;array = (List&lt;String&gt;)cborArray.ToObject(
        typeof&#x28;List&lt;String&gt;));</code> .
    </example>
  </doc>
  <doc name='M:PeterO.Cbor.CBORObject.ToObject(System.Type,PeterO.Cbor.PODOptions)'>
    <summary>Converts this CBOR object to an object of an arbitrary type. See the
      documentation for the overload of this method taking a CBORTypeMapper and
      PODOptions parameters for more information. This method (without a
      CBORTypeMapper parameter) allows all data types not otherwise handled to
      be eligible for Plain-Old-Data serialization.
    </summary>
    <param name='t'>The type, class, or interface that this method's return value will belong
      to. To express a generic type in Java, see the example.
      <b>Note:</b> For security reasons, an application should not base this parameter on
      user input or other externally supplied data. Whenever possible, this
      parameter should be either a type specially handled by this method (such
      as
      <c>int</c> or
      <c>String</c> ) or a plain-old-data type (POCO or POJO type) within the control of the
      application. If the plain-old-data type references other data types, those
      types should likewise meet either criterion above.
    </param>
    <param name='options'>Specifies options for controlling deserialization of CBOR objects.
    </param>
    <returns>The converted object.
    </returns>
    <exception cref='T:System.NotSupportedException'>The given type
      <paramref name='t'/>
       , or this object's CBOR type, is not supported.
    </exception>
    <exception cref='T:System.ArgumentNullException'>The parameter
      <paramref name='t'/>
       is null.
    </exception>
    <exception cref='T:System.CBORException'>The given object's nesting is too deep, or another error occurred when
      serializing the object.
    </exception>
  </doc>
  <doc name='M:PeterO.Cbor.CBORObject.ToObject``1'>
    <summary><para>Converts this CBOR object to an object of an arbitrary type. See
        <see cref='M:PeterO.Cbor.CBORObject.ToObject(System.Type)'/>
         for further information.
      </para>
    </summary>
    <typeparam name='T'>The type, class, or interface that this method's return value will belong
      to.
      <b>Note:</b> For security reasons, an application should not base this parameter on
      user input or other externally supplied data. Whenever possible, this
      parameter should be either a type specially handled by this method (such
      as
      <c>int</c> or
      <c>String</c> ) or a plain-old-data type (POCO or POJO type) within the control of the
      application. If the plain-old-data type references other data types, those
      types should likewise meet either criterion above.
    </typeparam>
    <returns>The converted object.
    </returns>
    <exception cref='T:System.NotSupportedException'>The given type "T", or this object's CBOR type, is not supported.
    </exception>
  </doc>
  <doc name='M:PeterO.Cbor.CBORObject.ToObject``1(PeterO.Cbor.CBORTypeMapper)'>
    <summary><para>Converts this CBOR object to an object of an arbitrary type. See
        <see cref='M:PeterO.Cbor.CBORObject.ToObject(System.Type)'/>
         for further information.
      </para>
    </summary>
    <param name='mapper'>This parameter controls which data types are eligible for Plain-Old-Data
      deserialization and includes custom converters from CBOR objects to
      certain data types.
    </param>
    <typeparam name='T'>The type, class, or interface that this method's return value will belong
      to.
      <b>Note:</b> For security reasons, an application should not base this parameter on
      user input or other externally supplied data. Whenever possible, this
      parameter should be either a type specially handled by this method (such
      as
      <c>int</c> or
      <c>String</c> ) or a plain-old-data type (POCO or POJO type) within the control of the
      application. If the plain-old-data type references other data types, those
      types should likewise meet either criterion above.
    </typeparam>
    <returns>The converted object.
    </returns>
    <exception cref='T:System.NotSupportedException'>The given type "T", or this object's CBOR type, is not supported.
    </exception>
  </doc>
  <doc name='M:PeterO.Cbor.CBORObject.ToObject``1(PeterO.Cbor.CBORTypeMapper,PeterO.Cbor.PODOptions)'>
    <summary><para>Converts this CBOR object to an object of an arbitrary type. See
        <see cref='M:PeterO.Cbor.CBORObject.ToObject(System.Type)'/>
         for further information.
      </para>
    </summary>
    <param name='mapper'>This parameter controls which data types are eligible for Plain-Old-Data
      deserialization and includes custom converters from CBOR objects to
      certain data types.
    </param>
    <param name='options'>Specifies options for controlling deserialization of CBOR objects.
    </param>
    <typeparam name='T'>The type, class, or interface that this method's return value will belong
      to.
      <b>Note:</b> For security reasons, an application should not base this parameter on
      user input or other externally supplied data. Whenever possible, this
      parameter should be either a type specially handled by this method (such
      as
      <c>int</c> or
      <c>String</c> ) or a plain-old-data type (POCO or POJO type) within the control of the
      application. If the plain-old-data type references other data types, those
      types should likewise meet either criterion above.
    </typeparam>
    <returns>The converted object.
    </returns>
    <exception cref='T:System.NotSupportedException'>The given type "T", or this object's CBOR type, is not supported.
    </exception>
  </doc>
  <doc name='M:PeterO.Cbor.CBORObject.ToObject``1(PeterO.Cbor.PODOptions)'>
    <summary><para>Converts this CBOR object to an object of an arbitrary type. See
        <see cref='M:PeterO.Cbor.CBORObject.ToObject(System.Type)'/>
         for further information.
      </para>
    </summary>
    <param name='options'>Specifies options for controlling deserialization of CBOR objects.
    </param>
    <typeparam name='T'>The type, class, or interface that this method's return value will belong
      to.
      <b>Note:</b> For security reasons, an application should not base this parameter on
      user input or other externally supplied data. Whenever possible, this
      parameter should be either a type specially handled by this method (such
      as
      <c>int</c> or
      <c>String</c> ) or a plain-old-data type (POCO or POJO type) within the control of the
      application. If the plain-old-data type references other data types, those
      types should likewise meet either criterion above.
    </typeparam>
    <returns>The converted object.
    </returns>
    <exception cref='T:System.NotSupportedException'>The given type "T", or this object's CBOR type, is not supported.
    </exception>
  </doc>
  <doc name='M:PeterO.Cbor.CBORObject.ToString'>
    <summary>Returns this CBOR object in string form. The format is intended to be
      human-readable, not machine-readable, the format is not intended to be
      parsed, and the format may change at any time. The returned string is not
      necessarily in JavaScript Object Notation (JSON); to convert CBOR objects
      to JSON strings, use the
      <see cref='M:PeterO.Cbor.CBORObject.ToJSONString(PeterO.Cbor.JSONOptions)'/>
       method instead.
    </summary>
    <returns>A text representation of this object.
    </returns>
  </doc>
  <doc name='F:PeterO.Cbor.CBORObject.True'>
    <summary>Represents the value true.
    </summary>
  </doc>
  <doc name='P:PeterO.Cbor.CBORObject.Type'>
    <summary>Gets the general data type of this CBOR object.
    </summary>
    <value>The general data type of this CBOR object.
    </value>
  </doc>
  <doc name='F:PeterO.Cbor.CBORObject.Undefined'>
    <summary>Represents the value undefined.
    </summary>
  </doc>
  <doc name='M:PeterO.Cbor.CBORObject.Untag'>
    <summary>Gets an object with the same value as this one but without the tags it
      has, if any. If this object is an array, map, or byte string, the data
      will not be copied to the returned object, so changes to the returned
      object will be reflected in this one.
    </summary>
    <returns>A CBORObject object.
    </returns>
  </doc>
  <doc name='M:PeterO.Cbor.CBORObject.UntagOne'>
    <summary>Gets an object with the same value as this one but without this object's
      outermost tag, if any. If this object is an array, map, or byte string,
      the data will not be copied to the returned object, so changes to the
      returned object will be reflected in this one.
    </summary>
    <returns>A CBORObject object.
    </returns>
  </doc>
  <doc name='P:PeterO.Cbor.CBORObject.Values'>
    <summary>Gets a collection of the values of this CBOR object, if it's a map or an
      array. If this object is a map, returns one value for each key in the map
      in an undefined order. If this is an array, returns all the values of the
      array in the order they are listed. (This method can't be used to get the
      bytes in a CBOR byte string; for that, use the GetByteString method
      instead.).
    </summary>
    <value>A collection of the values of this CBOR map or array.
    </value>
    <exception cref='T:System.InvalidOperationException'>This object is not a map or an array.
    </exception>
  </doc>
  <doc name='M:PeterO.Cbor.CBORObject.Write(PeterO.BigInteger,System.IO.Stream)'>
    <summary>Writes a big integer in CBOR format to a data stream.
    </summary>
    <param name='bigint'>Big integer to write. Can be null.
    </param>
    <param name='stream'>A writable data stream.
    </param>
    <exception cref='T:System.ArgumentNullException'>The parameter
      <paramref name='stream'/>
       is null.
    </exception>
    <exception cref='T:System.IO.IOException'>An I/O error occurred.
    </exception>
  </doc>
  <doc name='M:PeterO.Cbor.CBORObject.Write(PeterO.Cbor.CBORObject,System.IO.Stream)'>
    <summary>Writes a CBOR object to a CBOR data stream.
    </summary>
    <param name='value'>The value to write. Can be null.
    </param>
    <param name='stream'>A writable data stream.
    </param>
    <exception cref='T:System.ArgumentNullException'>The parameter
      <paramref name='stream'/>
       is null.
    </exception>
  </doc>
  <doc name='M:PeterO.Cbor.CBORObject.Write(PeterO.ExtendedDecimal,System.IO.Stream)'>
    <summary>Writes a decimal floating-point number in CBOR format to a data stream, as
      follows:
      <list type=''>
        <item>If the value is null, writes the byte 0xF6.
        </item>
        <item>If the value is negative zero, infinity, or NaN, converts the number
          to a
          <c>double</c> and writes that
          <c>double</c> . If negative zero should not be written this way, use the Plus
          method to convert the value beforehand.
        </item>
        <item>If the value has an exponent of zero, writes the value as an unsigned
          integer or signed integer if the number can fit either type or as a
          big integer otherwise.
        </item>
        <item>In all other cases, writes the value as a decimal number.
        </item>
      </list>
    </summary>
    <param name='bignum'>The arbitrary-precision decimal number to write. Can be null.
    </param>
    <param name='stream'>Stream to write to.
    </param>
    <exception cref='T:System.ArgumentNullException'>The parameter
      <paramref name='stream'/>
       is null.
    </exception>
    <exception cref='T:System.IO.IOException'>An I/O error occurred.
    </exception>
  </doc>
  <doc name='M:PeterO.Cbor.CBORObject.Write(PeterO.ExtendedFloat,System.IO.Stream)'>
    <summary>Writes a binary floating-point number in CBOR format to a data stream as
      follows:
      <list type=''>
        <item>If the value is null, writes the byte 0xF6.
        </item>
        <item>If the value is negative zero, infinity, or NaN, converts the number
          to a
          <c>double</c> and writes that
          <c>double</c> . If negative zero should not be written this way, use the Plus
          method to convert the value beforehand.
        </item>
        <item>If the value has an exponent of zero, writes the value as an unsigned
          integer or signed integer if the number can fit either type or as a
          big integer otherwise.
        </item>
        <item>In all other cases, writes the value as a big float.
        </item>
      </list>
    </summary>
    <param name='bignum'>An arbitrary-precision binary float.
    </param>
    <param name='stream'>A writable data stream.
    </param>
    <exception cref='T:System.ArgumentNullException'>The parameter
      <paramref name='stream'/>
       is null.
    </exception>
    <exception cref='T:System.IO.IOException'>An I/O error occurred.
    </exception>
  </doc>
  <doc name='M:PeterO.Cbor.CBORObject.Write(PeterO.ExtendedRational,System.IO.Stream)'>
    <summary>Writes a rational number in CBOR format to a data stream.
    </summary>
    <param name='rational'>An arbitrary-precision rational number.
    </param>
    <param name='stream'>A writable data stream.
    </param>
    <exception cref='T:System.ArgumentNullException'>The parameter
      <paramref name='stream'/>
       is null.
    </exception>
    <exception cref='T:System.IO.IOException'>An I/O error occurred.
    </exception>
  </doc>
  <doc name='M:PeterO.Cbor.CBORObject.Write(PeterO.Numbers.EDecimal,System.IO.Stream)'>
    <summary>Writes a decimal floating-point number in CBOR format to a data stream, as
      follows:
      <list type=''>
        <item>If the value is null, writes the byte 0xF6.
        </item>
        <item>If the value is negative zero, infinity, or NaN, converts the number
          to a
          <c>double</c> and writes that
          <c>double</c> . If negative zero should not be written this way, use the Plus
          method to convert the value beforehand.
        </item>
        <item>If the value has an exponent of zero, writes the value as an unsigned
          integer or signed integer if the number can fit either type or as a
          big integer otherwise.
        </item>
        <item>In all other cases, writes the value as a decimal number.
        </item>
      </list>
    </summary>
    <param name='bignum'>The arbitrary-precision decimal number to write. Can be null.
    </param>
    <param name='stream'>Stream to write to.
    </param>
    <exception cref='T:System.ArgumentNullException'>The parameter
      <paramref name='stream'/>
       is null.
    </exception>
    <exception cref='T:System.IO.IOException'>An I/O error occurred.
    </exception>
  </doc>
  <doc name='M:PeterO.Cbor.CBORObject.Write(PeterO.Numbers.EFloat,System.IO.Stream)'>
    <summary>Writes a binary floating-point number in CBOR format to a data stream as
      follows:
      <list type=''>
        <item>If the value is null, writes the byte 0xF6.
        </item>
        <item>If the value is negative zero, infinity, or NaN, converts the number
          to a
          <c>double</c> and writes that
          <c>double</c> . If negative zero should not be written this way, use the Plus
          method to convert the value beforehand.
        </item>
        <item>If the value has an exponent of zero, writes the value as an unsigned
          integer or signed integer if the number can fit either type or as a
          big integer otherwise.
        </item>
        <item>In all other cases, writes the value as a big float.
        </item>
      </list>
    </summary>
    <param name='bignum'>An arbitrary-precision binary float.
    </param>
    <param name='stream'>A writable data stream.
    </param>
    <exception cref='T:System.ArgumentNullException'>The parameter
      <paramref name='stream'/>
       is null.
    </exception>
    <exception cref='T:System.IO.IOException'>An I/O error occurred.
    </exception>
  </doc>
  <doc name='M:PeterO.Cbor.CBORObject.Write(PeterO.Numbers.EInteger,System.IO.Stream)'>
    <summary>Writes a big integer in CBOR format to a data stream.
    </summary>
    <param name='bigint'>Big integer to write. Can be null.
    </param>
    <param name='stream'>A writable data stream.
    </param>
    <exception cref='T:System.ArgumentNullException'>The parameter
      <paramref name='stream'/>
       is null.
    </exception>
    <exception cref='T:System.IO.IOException'>An I/O error occurred.
    </exception>
  </doc>
  <doc name='M:PeterO.Cbor.CBORObject.Write(PeterO.Numbers.ERational,System.IO.Stream)'>
    <summary>Writes a rational number in CBOR format to a data stream.
    </summary>
    <param name='rational'>An arbitrary-precision rational number.
    </param>
    <param name='stream'>A writable data stream.
    </param>
    <exception cref='T:System.ArgumentNullException'>The parameter
      <paramref name='stream'/>
       is null.
    </exception>
    <exception cref='T:System.IO.IOException'>An I/O error occurred.
    </exception>
  </doc>
  <doc name='M:PeterO.Cbor.CBORObject.Write(System.Boolean,System.IO.Stream)'>
    <summary>Writes a Boolean value in CBOR format to a data stream.
    </summary>
    <param name='value'>The value to write.
    </param>
    <param name='stream'>A writable data stream.
    </param>
    <exception cref='T:System.ArgumentNullException'>The parameter
      <paramref name='stream'/>
       is null.
    </exception>
    <exception cref='T:System.IO.IOException'>An I/O error occurred.
    </exception>
  </doc>
  <doc name='M:PeterO.Cbor.CBORObject.Write(System.Byte,System.IO.Stream)'>
    <summary>Writes a byte (0 to 255) in CBOR format to a data stream. If the value is
      less than 24, writes that byte. If the value is 25 to 255, writes the byte
      24, then this byte's value.
    </summary>
    <param name='value'>The value to write.
    </param>
    <param name='stream'>A writable data stream.
    </param>
    <exception cref='T:System.ArgumentNullException'>The parameter
      <paramref name='stream'/>
       is null.
    </exception>
    <exception cref='T:System.IO.IOException'>An I/O error occurred.
    </exception>
  </doc>
  <doc name='M:PeterO.Cbor.CBORObject.Write(System.Char,System.IO.Stream)'>
    <summary>Writes a Unicode character as a string in CBOR format to a data stream.
    </summary>
    <param name='value'>The value to write.
    </param>
    <param name='stream'>A writable data stream.
    </param>
    <exception cref='T:System.ArgumentNullException'>The parameter
      <paramref name='stream'/>
       is null.
    </exception>
    <exception cref='T:System.ArgumentException'>The parameter
      <paramref name='value'/>
       is a surrogate code point.
    </exception>
    <exception cref='T:System.IO.IOException'>An I/O error occurred.
    </exception>
  </doc>
  <doc name='M:PeterO.Cbor.CBORObject.Write(System.Double,System.IO.Stream)'>
    <summary>Writes a 64-bit floating-point number in CBOR format to a data stream.
    </summary>
    <param name='value'>The value to write.
    </param>
    <param name='stream'>A writable data stream.
    </param>
    <exception cref='T:System.ArgumentNullException'>The parameter
      <paramref name='stream'/>
       is null.
    </exception>
    <exception cref='T:System.IO.IOException'>An I/O error occurred.
    </exception>
  </doc>
  <doc name='M:PeterO.Cbor.CBORObject.Write(System.Int16,System.IO.Stream)'>
    <summary>Writes a 16-bit signed integer in CBOR format to a data stream.
    </summary>
    <param name='value'>The value to write.
    </param>
    <param name='stream'>A writable data stream.
    </param>
    <exception cref='T:System.ArgumentNullException'>The parameter
      <paramref name='stream'/>
       is null.
    </exception>
    <exception cref='T:System.IO.IOException'>An I/O error occurred.
    </exception>
  </doc>
  <doc name='M:PeterO.Cbor.CBORObject.Write(System.Int32,System.IO.Stream)'>
    <summary>Writes a 32-bit signed integer in CBOR format to a data stream.
    </summary>
    <param name='value'>The value to write.
    </param>
    <param name='stream'>A writable data stream.
    </param>
    <exception cref='T:System.ArgumentNullException'>The parameter
      <paramref name='stream'/>
       is null.
    </exception>
    <exception cref='T:System.IO.IOException'>An I/O error occurred.
    </exception>
  </doc>
  <doc name='M:PeterO.Cbor.CBORObject.Write(System.Int64,System.IO.Stream)'>
    <summary>Writes a 64-bit signed integer in CBOR format to a data stream.
    </summary>
    <param name='value'>The value to write.
    </param>
    <param name='stream'>A writable data stream.
    </param>
    <exception cref='T:System.ArgumentNullException'>The parameter
      <paramref name='stream'/>
       is null.
    </exception>
    <exception cref='T:System.IO.IOException'>An I/O error occurred.
    </exception>
  </doc>
  <doc name='M:PeterO.Cbor.CBORObject.Write(System.Object,System.IO.Stream)'>
    <summary><para>Writes a CBOR object to a CBOR data stream. See the three-parameter
        Write method that takes a CBOREncodeOptions.
      </para>
    </summary>
    <param name='objValue'>The parameter
      <paramref name='objValue'/>
       is an arbitrary object.
    </param>
    <param name='stream'>A writable data stream.
    </param>
  </doc>
  <doc name='M:PeterO.Cbor.CBORObject.Write(System.Object,System.IO.Stream,PeterO.Cbor.CBOREncodeOptions)'>
    <summary>Writes an arbitrary object to a CBOR data stream, using the specified
      options for controlling how the object is encoded to CBOR data format. If
      the object is convertible to a CBOR map or a CBOR object that contains
      CBOR maps, the keys to those maps are written out to the data stream in an
      undefined order. The example code given in
      <see cref='M:PeterO.Cbor.CBORObject.WriteTo(System.IO.Stream)'/>
       can be used to write out certain keys of a CBOR map in a given order.
      Currently, the following objects are supported:
      <list type=''>
        <item>Lists of CBORObject.
        </item>
        <item>Maps of CBORObject. The keys to the map are written out to the data
          stream in an undefined order.
        </item>
        <item>Null.
        </item>
        <item>Byte arrays, which will always be written as definite-length byte
          strings.
        </item>
        <item>String objects. The strings will be encoded using definite-length
          encoding regardless of their length.
        </item>
        <item>Any object accepted by the FromObject static methods.
        </item>
      </list>
    </summary>
    <param name='objValue'>The arbitrary object to be serialized. Can be null.
    </param>
    <param name='output'>A writable data stream.
    </param>
    <param name='options'>CBOR options for encoding the CBOR object to bytes.
    </param>
    <exception cref='T:System.ArgumentException'>The object's type is not supported.
    </exception>
    <exception cref='T:System.ArgumentNullException'>The parameter
      <paramref name='options'/>
       or
      <paramref name='output'/>
       is null.
    </exception>
  </doc>
  <doc name='M:PeterO.Cbor.CBORObject.Write(System.SByte,System.IO.Stream)'>
    <summary>Writes an 8-bit signed integer in CBOR format to a data stream.
    </summary>
    <param name='value'>The parameter
      <paramref name='value'/>
       is an 8-bit signed integer.
    </param>
    <param name='stream'>A writable data stream.
    </param>
  </doc>
  <doc name='M:PeterO.Cbor.CBORObject.Write(System.Single,System.IO.Stream)'>
    <summary>Writes a 32-bit floating-point number in CBOR format to a data stream.
    </summary>
    <param name='value'>The value to write.
    </param>
    <param name='s'>A writable data stream.
    </param>
    <exception cref='T:System.ArgumentNullException'>The parameter
      <paramref name='s'/>
       is null.
    </exception>
    <exception cref='T:System.IO.IOException'>An I/O error occurred.
    </exception>
  </doc>
  <doc name='M:PeterO.Cbor.CBORObject.Write(System.String,System.IO.Stream)'>
    <summary><para>Writes a string in CBOR format to a data stream. The string will be
        encoded using definite-length encoding regardless of its length.
      </para>
    </summary>
    <param name='str'>The string to write. Can be null.
    </param>
    <param name='stream'>A writable data stream.
    </param>
    <exception cref='T:System.ArgumentNullException'>The parameter
      <paramref name='stream'/>
       is null.
    </exception>
    <exception cref='T:System.IO.IOException'>An I/O error occurred.
    </exception>
  </doc>
  <doc name='M:PeterO.Cbor.CBORObject.Write(System.String,System.IO.Stream,PeterO.Cbor.CBOREncodeOptions)'>
    <summary>Writes a string in CBOR format to a data stream, using the given options
      to control the encoding process.
    </summary>
    <param name='str'>The string to write. Can be null.
    </param>
    <param name='stream'>A writable data stream.
    </param>
    <param name='options'>Options for encoding the data to CBOR.
    </param>
    <exception cref='T:System.ArgumentNullException'>The parameter
      <paramref name='stream'/>
       is null.
    </exception>
    <exception cref='T:System.IO.IOException'>An I/O error occurred.
    </exception>
  </doc>
  <doc name='M:PeterO.Cbor.CBORObject.Write(System.UInt16,System.IO.Stream)'>
    <summary>Writes a 16-bit unsigned integer in CBOR format to a data stream.
    </summary>
    <param name='value'>A 16-bit unsigned integer.
    </param>
    <param name='stream'>A writable data stream.
    </param>
  </doc>
  <doc name='M:PeterO.Cbor.CBORObject.Write(System.UInt32,System.IO.Stream)'>
    <summary>Writes a 32-bit unsigned integer in CBOR format to a data stream.
    </summary>
    <param name='value'>A 32-bit unsigned integer.
    </param>
    <param name='stream'>A writable data stream.
    </param>
  </doc>
  <doc name='M:PeterO.Cbor.CBORObject.Write(System.UInt64,System.IO.Stream)'>
    <summary>Writes a 64-bit unsigned integer in CBOR format to a data stream.
    </summary>
    <param name='value'>A 64-bit unsigned integer.
    </param>
    <param name='stream'>A writable data stream.
    </param>
    <exception cref='T:System.ArgumentNullException'>The parameter
      <paramref name='stream'/>
       is null.
    </exception>
  </doc>
  <doc name='M:PeterO.Cbor.CBORObject.WriteJSON(System.Object,System.IO.Stream)'>
    <summary>Converts an arbitrary object to a string in JavaScript Object Notation
      (JSON) format, as in the ToJSONString method, and writes that string to a
      data stream in UTF-8. If the object is convertible to a CBOR map, or to a
      CBOR object that contains CBOR maps, the keys to those maps are written
      out to the JSON string in an undefined order. The example code given in
      <see cref='M:PeterO.Cbor.CBORObject.ToJSONString(PeterO.Cbor.JSONOptions)'/>
       can be used to write out certain keys of a CBOR map in a given order to a
      JSON string.
    </summary>
    <param name='obj'>The parameter
      <paramref name='obj'/>
       is an arbitrary object.
    </param>
    <param name='outputStream'>A writable data stream.
    </param>
  </doc>
  <doc name='M:PeterO.Cbor.CBORObject.WriteJSONTo(System.IO.Stream)'>
    <summary>Converts this object to a string in JavaScript Object Notation (JSON)
      format, as in the ToJSONString method, and writes that string to a data
      stream in UTF-8. If the CBOR object contains CBOR maps, or is a CBOR map,
      the keys to the map are written out to the JSON string in an undefined
      order. The example code given in
      <see cref='M:PeterO.Cbor.CBORObject.ToJSONString(PeterO.Cbor.JSONOptions)'/>
       can be used to write out certain keys of a CBOR map in a given order to a
      JSON string.
    </summary>
    <param name='outputStream'>A writable data stream.
    </param>
    <exception cref='T:System.IO.IOException'>An I/O error occurred.
    </exception>
    <exception cref='T:System.ArgumentNullException'>The parameter
      <paramref name='outputStream'/>
       is null.
    </exception>
  </doc>
  <doc name='M:PeterO.Cbor.CBORObject.WriteJSONTo(System.IO.Stream,PeterO.Cbor.JSONOptions)'>
    <summary>Converts this object to a string in JavaScript Object Notation (JSON)
      format, as in the ToJSONString method, and writes that string to a data
      stream in UTF-8, using the given JSON options to control the encoding
      process. If the CBOR object contains CBOR maps, or is a CBOR map, the keys
      to the map are written out to the JSON string in an undefined order. The
      example code given in
      <see cref='M:PeterO.Cbor.CBORObject.ToJSONString(PeterO.Cbor.JSONOptions)'/>
       can be used to write out certain keys of a CBOR map in a given order to a
      JSON string.
    </summary>
    <param name='outputStream'>A writable data stream.
    </param>
    <param name='options'>An object containing the options to control writing the CBOR object to
      JSON.
    </param>
    <exception cref='T:System.IO.IOException'>An I/O error occurred.
    </exception>
    <exception cref='T:System.ArgumentNullException'>The parameter
      <paramref name='outputStream'/>
       is null.
    </exception>
  </doc>
  <doc name='M:PeterO.Cbor.CBORObject.WriteTo(System.IO.Stream)'>
    <summary><para>Writes this CBOR object to a data stream. If the CBOR object contains
        CBOR maps, or is a CBOR map, the keys to the map are written out to the
        data stream in an undefined order. See the examples (written in C# for
        the .NET version) for ways to write out certain keys of a CBOR map in a
        given order.
      </para>
    </summary>
    <param name='stream'>A writable data stream.
    </param>
    <exception cref='T:System.ArgumentNullException'>The parameter
      <paramref name='stream'/>
       is null.
    </exception>
    <exception cref='T:System.IO.IOException'>An I/O error occurred.
    </exception>
    <example><para>The following example shows a method that writes each key of 'mapObj' to
        'outputStream', in the order given in 'keys', where 'mapObj' is written
        out in the form of a CBOR
        <b>definite-length map</b> . Only keys found in 'keys' will be written if they exist in 'mapObj'.
      </para>
      <code>private static void WriteKeysToMap&#x28;CBORObject mapObj,
        IList&lt;CBORObject&gt; keys, Stream outputStream)&#x7b; if&#x28;mapObj
        == null)&#x7b; throw new
        ArgumentNullException&#x28;nameof(mapObj));&#x7d; if&#x28;keys ==
        null)&#x7b;throw new ArgumentNullException&#x28;nameof(keys));&#x7d;
        if&#x28;outputStream == null)&#x7b;throw new
        ArgumentNullException&#x28;nameof(outputStream));&#x7d;
        if&#x28;obj.Type!=CBORType.Map)&#x7b; throw new ArgumentException("'obj'
        is not a map."); &#x7d; int keyCount = 0; for (CBORObject key in keys)
        &#x7b; if&#x28;mapObj.ContainsKey(key))&#x7b; keyCount++; &#x7d; &#x7d;
        CBORObject.WriteValue(outputStream, 5, keyCount); for (CBORObject key in
        keys) &#x7b; if&#x28;mapObj.ContainsKey(key))&#x7b;
        key.WriteTo(outputStream); mapObj[key].WriteTo(outputStream); &#x7d;
        &#x7d; &#x7d;</code> <para>The following example shows a method that writes each key of 'mapObj' to
        'outputStream', in the order given in 'keys', where 'mapObj' is written
        out in the form of a CBOR
        <b>indefinite-length map</b> . Only keys found in 'keys' will be written if they exist in 'mapObj'.
      </para>
      <code>private static void WriteKeysToIndefMap&#x28;CBORObject mapObj,
        IList&lt;CBORObject&gt; keys, Stream outputStream)&#x7b; if&#x28;mapObj
        == null)&#x7b; throw new
        ArgumentNullException&#x28;nameof(mapObj));&#x7d; if&#x28;keys ==
        null)&#x7b;throw new ArgumentNullException&#x28;nameof(keys));&#x7d;
        if&#x28;outputStream == null)&#x7b;throw new
        ArgumentNullException&#x28;nameof(outputStream));&#x7d;
        if&#x28;obj.Type!=CBORType.Map)&#x7b; throw new ArgumentException("'obj'
        is not a map."); &#x7d; outputStream.WriteByte((byte)0xBF); for
        (CBORObject key in keys) &#x7b; if&#x28;mapObj.ContainsKey(key))&#x7b;
        key.WriteTo(outputStream); mapObj[key].WriteTo(outputStream); &#x7d;
        &#x7d; outputStream.WriteByte((byte)0xff); &#x7d;</code> <para>The following example shows a method that writes out a list of objects
        to 'outputStream' as an
        <b>indefinite-length CBOR array</b> .
      </para>
      <code>private static void WriteToIndefArray&#x28; IList&lt;object&gt; list,
        Stream outputStream)&#x7b; if&#x28;list == null)&#x7b; throw new
        ArgumentNullException&#x28;nameof(list));&#x7d; if&#x28;outputStream ==
        null)&#x7b;throw new
        ArgumentNullException&#x28;nameof(outputStream));&#x7d;
        outputStream.WriteByte((byte)0x9f); for (object item in list) &#x7b; new
        CBORObject(item).WriteTo(outputStream); &#x7d;
        outputStream.WriteByte((byte)0xff); &#x7d;</code> .
    </example>
  </doc>
  <doc name='M:PeterO.Cbor.CBORObject.WriteTo(System.IO.Stream,PeterO.Cbor.CBOREncodeOptions)'>
    <summary>Writes this CBOR object to a data stream, using the specified options for
      encoding the data to CBOR format. If the CBOR object contains CBOR maps,
      or is a CBOR map, the keys to the map are written out to the data stream
      in an undefined order. The example code given in
      <see cref='M:PeterO.Cbor.CBORObject.WriteTo(System.IO.Stream)'/>
       can be used to write out certain keys of a CBOR map in a given order.
    </summary>
    <param name='stream'>A writable data stream.
    </param>
    <param name='options'>Options for encoding the data to CBOR.
    </param>
    <exception cref='T:System.ArgumentNullException'>The parameter
      <paramref name='stream'/>
       is null.
    </exception>
    <exception cref='T:System.IO.IOException'>An I/O error occurred.
    </exception>
    <exception cref='T:System.ArgumentException'>Unexpected data type".
    </exception>
  </doc>
  <doc name='M:PeterO.Cbor.CBORObject.WriteValue(System.IO.Stream,System.Int32,PeterO.Numbers.EInteger)'>
    <summary>Writes a CBOR major type number and an integer 0 or greater associated
      with it to a data stream, where that integer is passed to this method as
      an arbitrary-precision integer. This is a low-level method that is useful
      for implementing custom CBOR encoding methodologies. This method encodes
      the given major type and value in the shortest form allowed for the major
      type.
    </summary>
    <param name='outputStream'>A writable data stream.
    </param>
    <param name='majorType'>The CBOR major type to write. This is a number from 0 through 7 as
      follows. 0: integer 0 or greater; 1: negative integer; 2: byte string; 3:
      UTF-8 text string; 4: array; 5: map; 6: tag; 7: simple value. See RFC 7049
      for details on these major types.
    </param>
    <param name='bigintValue'>An integer 0 or greater associated with the major type, as follows. 0:
      integer 0 or greater; 1: the negative integer's absolute value is 1 plus
      this number; 2: length in bytes of the byte string; 3: length in bytes of
      the UTF-8 text string; 4: number of items in the array; 5: number of
      key-value pairs in the map; 6: tag number; 7: simple value number, which
      must be in the interval [0, 23] or [32, 255]. For major types 0 to 6, this
      number may not be greater than 2^64 - 1.
    </param>
    <returns>The number of bytes ordered to be written to the data stream.
    </returns>
    <exception cref='T:System.ArgumentException'>The parameter
      <paramref name='majorType'/>
       is 7 and value is greater than 255.
    </exception>
    <exception cref='T:System.ArgumentNullException'>The parameter
      <paramref name='outputStream'/>
       or
      <paramref name='bigintValue'/>
       is null.
    </exception>
  </doc>
  <doc name='M:PeterO.Cbor.CBORObject.WriteValue(System.IO.Stream,System.Int32,System.Int32)'>
    <summary>Writes a CBOR major type number and an integer 0 or greater associated
      with it to a data stream, where that integer is passed to this method as a
      32-bit signed integer. This is a low-level method that is useful for
      implementing custom CBOR encoding methodologies. This method encodes the
      given major type and value in the shortest form allowed for the major
      type.
    </summary>
    <param name='outputStream'>A writable data stream.
    </param>
    <param name='majorType'>The CBOR major type to write. This is a number from 0 through 7 as
      follows. 0: integer 0 or greater; 1: negative integer; 2: byte string; 3:
      UTF-8 text string; 4: array; 5: map; 6: tag; 7: simple value. See RFC 7049
      for details on these major types.
    </param>
    <param name='value'>An integer 0 or greater associated with the major type, as follows. 0:
      integer 0 or greater; 1: the negative integer's absolute value is 1 plus
      this number; 2: length in bytes of the byte string; 3: length in bytes of
      the UTF-8 text string; 4: number of items in the array; 5: number of
      key-value pairs in the map; 6: tag number; 7: simple value number, which
      must be in the interval [0, 23] or [32, 255].
    </param>
    <returns>The number of bytes ordered to be written to the data stream.
    </returns>
    <exception cref='T:System.ArgumentException'>Value is from 24 to 31 and major type is 7.
    </exception>
    <exception cref='T:System.ArgumentNullException'>The parameter
      <paramref name='outputStream'/>
       is null.
    </exception>
    <example><para>In the following example, an array of three objects is written as CBOR
        to a data stream.
      </para>
      <code>CBORObject.WriteValue(stream, 4, 3); /* array, length 3 */
        CBORObject.Write("hello world", stream); /* item 1 */
        CBORObject.Write(25, stream); /* item 2 */ CBORObject.Write(false,
        stream); // item 3</code> <para>In the following example, a map consisting of two key-value pairs is
        written as CBOR to a data stream.
      </para>
      <code>CBORObject.WriteValue(stream, 5, 2); // map, 2 pairs
        CBORObject.Write("number", stream); // key 1 CBORObject.Write(25,
        stream); // value 1 CBORObject.Write("string", stream); // key 2
        CBORObject.Write("hello", stream); // value 2</code> <para>In the following example (originally written in C# for the .NET
        Framework version), a text string is written as CBOR to a data stream.
      </para>
      <code>string str = "hello world"; byte[] bytes =
        DataUtilities.GetUtf8Bytes(str, true); CBORObject.WriteValue(stream, 4,
        bytes.Length); stream.Write(bytes, 0, bytes.Length);</code> .
    </example>
  </doc>
  <doc name='M:PeterO.Cbor.CBORObject.WriteValue(System.IO.Stream,System.Int32,System.Int64)'>
    <summary>Writes a CBOR major type number and an integer 0 or greater associated
      with it to a data stream, where that integer is passed to this method as a
      64-bit signed integer. This is a low-level method that is useful for
      implementing custom CBOR encoding methodologies. This method encodes the
      given major type and value in the shortest form allowed for the major
      type.
    </summary>
    <param name='outputStream'>A writable data stream.
    </param>
    <param name='majorType'>The CBOR major type to write. This is a number from 0 through 7 as
      follows. 0: integer 0 or greater; 1: negative integer; 2: byte string; 3:
      UTF-8 text string; 4: array; 5: map; 6: tag; 7: simple value. See RFC 7049
      for details on these major types.
    </param>
    <param name='value'>An integer 0 or greater associated with the major type, as follows. 0:
      integer 0 or greater; 1: the negative integer's absolute value is 1 plus
      this number; 2: length in bytes of the byte string; 3: length in bytes of
      the UTF-8 text string; 4: number of items in the array; 5: number of
      key-value pairs in the map; 6: tag number; 7: simple value number, which
      must be in the interval [0, 23] or [32, 255].
    </param>
    <returns>The number of bytes ordered to be written to the data stream.
    </returns>
    <exception cref='T:System.ArgumentException'>Value is from 24 to 31 and major type is 7.
    </exception>
    <exception cref='T:System.ArgumentNullException'>The parameter
      <paramref name='outputStream'/>
       is null.
    </exception>
  </doc>
  <doc name='M:PeterO.Cbor.CBORObject.WriteValue(System.IO.Stream,System.Int32,System.UInt32)'>
    <summary>Writes a CBOR major type number and an integer 0 or greater associated
      with it to a data stream, where that integer is passed to this method as a
      32-bit unsigned integer. This is a low-level method that is useful for
      implementing custom CBOR encoding methodologies. This method encodes the
      given major type and value in the shortest form allowed for the major
      type.
    </summary>
    <param name='outputStream'>A writable data stream.
    </param>
    <param name='majorType'>The CBOR major type to write. This is a number from 0 through 7 as
      follows. 0: integer 0 or greater; 1: negative integer; 2: byte string; 3:
      UTF-8 text string; 4: array; 5: map; 6: tag; 7: simple value. See RFC 7049
      for details on these major types.
    </param>
    <param name='value'>An integer 0 or greater associated with the major type, as follows. 0:
      integer 0 or greater; 1: the negative integer's absolute value is 1 plus
      this number; 2: length in bytes of the byte string; 3: length in bytes of
      the UTF-8 text string; 4: number of items in the array; 5: number of
      key-value pairs in the map; 6: tag number; 7: simple value number, which
      must be in the interval [0, 23] or [32, 255].
    </param>
    <returns>The number of bytes ordered to be written to the data stream.
    </returns>
    <exception cref='T:System.ArgumentNullException'>The parameter
      <paramref name='outputStream'/>
       is null.
    </exception>
  </doc>
  <doc name='M:PeterO.Cbor.CBORObject.WriteValue(System.IO.Stream,System.Int32,System.UInt64)'>
    <summary>Writes a CBOR major type number and an integer 0 or greater associated
      with it to a data stream, where that integer is passed to this method as a
      64-bit unsigned integer. This is a low-level method that is useful for
      implementing custom CBOR encoding methodologies. This method encodes the
      given major type and value in the shortest form allowed for the major
      type.
    </summary>
    <param name='outputStream'>A writable data stream.
    </param>
    <param name='majorType'>The CBOR major type to write. This is a number from 0 through 7 as
      follows. 0: integer 0 or greater; 1: negative integer; 2: byte string; 3:
      UTF-8 text string; 4: array; 5: map; 6: tag; 7: simple value. See RFC 7049
      for details on these major types.
    </param>
    <param name='value'>An integer 0 or greater associated with the major type, as follows. 0:
      integer 0 or greater; 1: the negative integer's absolute value is 1 plus
      this number; 2: length in bytes of the byte string; 3: length in bytes of
      the UTF-8 text string; 4: number of items in the array; 5: number of
      key-value pairs in the map; 6: tag number; 7: simple value number, which
      must be in the interval [0, 23] or [32, 255].
    </param>
    <returns>The number of bytes ordered to be written to the data stream.
    </returns>
    <exception cref='T:System.ArgumentException'>The parameter
      <paramref name='majorType'/>
       is 7 and value is greater than 255.
    </exception>
    <exception cref='T:System.ArgumentNullException'>The parameter
      <paramref name='outputStream'/>
       is null.
    </exception>
  </doc>
  <doc name='F:PeterO.Cbor.CBORObject.Zero'>
    <summary>Gets a CBOR object for the number zero.
    </summary>
  </doc>
  <doc name='M:PeterO.Cbor.CBORObject.op_Addition(PeterO.Cbor.CBORObject,PeterO.Cbor.CBORObject)'>
    <summary>Adds two CBOR objects and returns their result.
    </summary>
    <param name='a'>The parameter
      <paramref name='a'/>
       is a CBOR object.
    </param>
    <param name='b'>The parameter
      <paramref name='b'/>
       is a CBOR object.
    </param>
    <returns>The sum of the two objects.
    </returns>
  </doc>
  <doc name='M:PeterO.Cbor.CBORObject.op_Division(PeterO.Cbor.CBORObject,PeterO.Cbor.CBORObject)'>
    <summary>Divides a CBORObject object by the value of a CBORObject object.
    </summary>
    <param name='a'>The parameter
      <paramref name='a'/>
       is a CBOR object.
    </param>
    <param name='b'>The parameter
      <paramref name='b'/>
       is a CBOR object.
    </param>
    <returns>The quotient of the two objects.
    </returns>
  </doc>
  <doc name='M:PeterO.Cbor.CBORObject.op_Modulus(PeterO.Cbor.CBORObject,PeterO.Cbor.CBORObject)'>
    <summary>Finds the remainder that results when a CBORObject object is divided by
      the value of a CBORObject object.
    </summary>
    <param name='a'>The parameter
      <paramref name='a'/>
       is a CBOR object.
    </param>
    <param name='b'>The parameter
      <paramref name='b'/>
       is a CBOR object.
    </param>
    <returns>The remainder of the two numbers.
    </returns>
  </doc>
  <doc name='M:PeterO.Cbor.CBORObject.op_Multiply(PeterO.Cbor.CBORObject,PeterO.Cbor.CBORObject)'>
    <summary>Multiplies a CBORObject object by the value of a CBORObject object.
    </summary>
    <param name='a'>The parameter
      <paramref name='a'/>
       is a CBOR object.
    </param>
    <param name='b'>The parameter
      <paramref name='b'/>
       is a CBOR object.
    </param>
    <returns>The product of the two numbers.
    </returns>
  </doc>
  <doc name='M:PeterO.Cbor.CBORObject.op_Subtraction(PeterO.Cbor.CBORObject,PeterO.Cbor.CBORObject)'>
    <summary>Subtracts a CBORObject object from a CBORObject object.
    </summary>
    <param name='a'>The parameter
      <paramref name='a'/>
       is a CBOR object.
    </param>
    <param name='b'>The parameter
      <paramref name='b'/>
       is a CBOR object.
    </param>
    <returns>The difference of the two objects.
    </returns>
  </doc>
  <doc name='T:PeterO.Cbor.CBORObjectMath'>
    <summary>Implements arithmetic operations with CBOR objects.
    </summary>
  </doc>
  <doc name='F:PeterO.Cbor.CBORReader.CBORDuplicatePolicy.Disallow'>
    <summary>This is an internal API.
    </summary>
  </doc>
  <doc name='F:PeterO.Cbor.CBORReader.CBORDuplicatePolicy.Overwrite'>
    <summary>This is an internal API.
    </summary>
  </doc>
  <doc name='T:PeterO.Cbor.CBORType'>
    <summary>Represents a type that a CBOR object can have.
    </summary>
  </doc>
  <doc name='F:PeterO.Cbor.CBORType.Array'>
    <summary>An array of CBOR objects.
    </summary>
  </doc>
  <doc name='F:PeterO.Cbor.CBORType.Boolean'>
    <summary>The simple values true and false.
    </summary>
  </doc>
  <doc name='F:PeterO.Cbor.CBORType.ByteString'>
    <summary>An array of bytes.
    </summary>
  </doc>
  <doc name='F:PeterO.Cbor.CBORType.Map'>
    <summary>A map of CBOR objects.
    </summary>
  </doc>
  <doc name='F:PeterO.Cbor.CBORType.Number'>
    <summary>A number of any kind, including integers, big integers, floating point
      numbers, and decimal numbers. The floating-point value Not-a-Number is
      also included in the Number type.
    </summary>
  </doc>
  <doc name='F:PeterO.Cbor.CBORType.SimpleValue'>
    <summary>A "simple value" other than floating point values, true, and false.
    </summary>
  </doc>
  <doc name='F:PeterO.Cbor.CBORType.TextString'>
    <summary>A text string.
    </summary>
  </doc>
  <doc name='T:PeterO.Cbor.CBORTypeMapper'>
    <summary>Holds converters to customize the serialization and deserialization
      behavior of
      <c>CBORObject.FromObject</c> and
      <c>CBORObject#ToObject</c> , as well as type filters for
      <c>ToObject</c> .
    </summary>
  </doc>
  <doc name='M:PeterO.Cbor.CBORTypeMapper.#ctor'>
    <summary>Initializes a new instance of the
      <see cref='CBORTypeMapper'/>
       class.
    </summary>
  </doc>
  <doc name='M:PeterO.Cbor.CBORTypeMapper.AddConverter``1(System.Type,PeterO.Cbor.ICBORConverter{``0})'>
    <summary>Registers an object that converts objects of a given type to CBOR objects
      (called a CBOR converter).
    </summary>
    <param name='type'>A Type object specifying the type that the converter converts to CBOR
      objects.
    </param>
    <param name='converter'>The parameter
      <paramref name='converter'/>
       is an ICBORConverter object.
    </param>
    <typeparam name='T'>Must be the same as the "type" parameter.
    </typeparam>
    <returns>This object.
    </returns>
    <exception cref='T:System.ArgumentNullException'>The parameter
      <paramref name='type'/>
       or
      <paramref name='converter'/>
       is null.
    </exception>
    <exception cref='T:System.ArgumentException'>Converter doesn't contain a proper ToCBORObject method".
    </exception>
  </doc>
  <doc name='M:PeterO.Cbor.CBORTypeMapper.AddTypeName(System.String)'>
    <summary>Adds the fully qualified name of a Java or .NET type for use in type
      matching.
    </summary>
    <param name='name'>The fully qualified name of a Java or .NET class (e.g.,
      <c>java.math.BigInteger</c> or
      <c>System.Globalization.CultureInfo</c> ).
    </param>
    <returns>This object.
    </returns>
    <exception cref='T:System.ArgumentNullException'>The parameter
      <paramref name='name'/>
       is null.
    </exception>
    <exception cref='T:System.ArgumentException'>The parameter
      <paramref name='name'/>
       is empty.
    </exception>
  </doc>
  <doc name='M:PeterO.Cbor.CBORTypeMapper.AddTypePrefix(System.String)'>
    <summary>Adds a prefix of a Java or .NET type for use in type matching. A type
      matches a prefix if its fully qualified name is or begins with that
      prefix, using codepoint-by-codepoint (case-sensitive) matching.
    </summary>
    <param name='prefix'>The prefix of a Java or .NET type (e.g., `java.math.` or
      `System.Globalization`).
    </param>
    <returns>This object.
    </returns>
    <exception cref='T:System.ArgumentNullException'>The parameter
      <paramref name='prefix'/>
       is null.
    </exception>
    <exception cref='T:System.ArgumentException'>The parameter
      <paramref name='prefix'/>
       is empty.
    </exception>
  </doc>
  <doc name='M:PeterO.Cbor.CBORTypeMapper.FilterTypeName(System.String)'>
    <summary>Returns whether the given Java or .NET type name fits the filters given in
      this mapper.
    </summary>
    <param name='typeName'>The fully qualified name of a Java or .NET class (e.g.,
      <c>java.math.BigInteger</c> or
      <c>System.Globalization.CultureInfo</c> ).
    </param>
    <returns>Either
      <c>true</c> if the given Java or .NET type name fits the filters given in this
      mapper, or
      <c>false</c> otherwise.
    </returns>
  </doc>
  <doc name='T:PeterO.Cbor.CBORUtilities'>
    <summary>Contains utility methods that may have use outside of the CBORObject
      class.
    </summary>
  </doc>
  <doc name='M:PeterO.Cbor.CBORUuidConverter.ToCBORObject(System.Guid)'>
    <summary>Internal API.
    </summary>
    <param name='obj'>The parameter
      <paramref name='obj'/>
       is an internal parameter.
    </param>
    <returns>A CBORObject object.
    </returns>
  </doc>
  <doc name='M:PeterO.Cbor.FastInteger2.Multiply(System.Int32)'>
    <summary>Internal API.
    </summary>
    <param name='val'>The parameter
      <paramref name='val'/>
       is an internal parameter.
    </param>
    <returns>A FastInteger2 object.
    </returns>
  </doc>
  <doc name='P:PeterO.Cbor.FastInteger2.Sign'>
    <summary>This is an internal API.
    </summary>
    <value>Internal API value.
    </value>
  </doc>
  <doc name='M:PeterO.Cbor.FastInteger2.Subtract(PeterO.Cbor.FastInteger2)'>
    <summary>Internal API.
    </summary>
    <param name='val'>The parameter
      <paramref name='val'/>
       is an internal parameter.
    </param>
    <returns>A FastInteger2 object.
    </returns>
  </doc>
  <doc name='M:PeterO.Cbor.FastInteger2.SubtractInt(System.Int32)'>
    <summary>Internal API.
    </summary>
    <param name='val'>The parameter
      <paramref name='val'/>
       is an internal parameter.
    </param>
    <returns>A FastInteger2 object.
    </returns>
  </doc>
  <doc name='T:PeterO.Cbor.ICBORConverter`1'>
    <summary>Interface implemented by classes that convert objects of arbitrary types
      to CBOR objects.
    </summary>
    <typeparam name='T'>Type to convert to a CBOR object.
    </typeparam>
  </doc>
  <doc name='M:PeterO.Cbor.ICBORConverter`1.ToCBORObject(`0)'>
    <summary>Converts an object to a CBOR object.
    </summary>
    <param name='obj'>An object to convert to a CBOR object.
    </param>
    <returns>A CBOR object.
    </returns>
  </doc>
  <doc name='T:PeterO.Cbor.ICBORObjectConverter`1'>
    <summary>Interface implemented by classes that convert objects of arbitrary types
      to and from CBOR objects.
    </summary>
    <typeparam name='T'>Type of objects that a class implementing this method can convert to and
      from CBOR objects.
    </typeparam>
  </doc>
  <doc name='M:PeterO.Cbor.ICBORObjectConverter`1.FromCBORObject(PeterO.Cbor.CBORObject)'>
    <summary>Converts a CBOR object to an object of a type supported by the
      implementing class.
    </summary>
    <param name='cbor'>A CBOR object to convert.
    </param>
    <returns>The converted object.
    </returns>
    <exception cref='T:PeterO.Cbor.CBORException'>An error occurred in the conversion; for example, the conversion doesn't
      support the given CBOR object.
    </exception>
  </doc>
  <doc name='T:PeterO.Cbor.ICBORTag'>
    <summary>Implemented by classes that validate CBOR objects belonging to a specific
      tag.
    </summary>
  </doc>
  <doc name='M:PeterO.Cbor.ICBORTag.GetTypeFilter'>
    <summary>Gets a type filter specifying what kinds of CBOR objects are supported by
      this tag.
    </summary>
    <returns>A CBOR type filter.
    </returns>
  </doc>
  <doc name='M:PeterO.Cbor.ICBORTag.ValidateObject(PeterO.Cbor.CBORObject)'>
    <summary>Generates a CBOR object based on the data of another object. If the data
      is not valid, should throw a CBORException.
    </summary>
    <param name='obj'>A CBOR object with the corresponding tag handled by the ICBORTag object.
    </param>
    <returns>A CBORObject object. Note that this method may choose to return the same
      object as the parameter.
    </returns>
  </doc>
  <doc name='T:PeterO.Cbor.ICBORToFromConverter`1'>
    <summary>Classes that implement this interface can support conversions from CBOR
      objects to a custom type and back.
    </summary>
    <typeparam name='T'>Type of objects to convert to and from CBOR objects.
    </typeparam>
  </doc>
  <doc name='M:PeterO.Cbor.ICBORToFromConverter`1.FromCBORObject(PeterO.Cbor.CBORObject)'>
    <summary>Converts a CBOR object to a custom type.
    </summary>
    <param name='obj'>A CBOR object to convert to the custom type.
    </param>
    <returns>An object of the custom type after conversion.
    </returns>
  </doc>
  <doc name='T:PeterO.Cbor.ICharacterInput'>
    <summary>An interface for reading Unicode characters from a data source.
    </summary>
  </doc>
  <doc name='M:PeterO.Cbor.ICharacterInput.Read(System.Int32[],System.Int32,System.Int32)'>
    <summary>Reads a sequence of Unicode code points from a data source.
    </summary>
    <param name='chars'>Output buffer.
    </param>
    <param name='index'>Index in the output buffer to start writing to.
    </param>
    <param name='length'>Maximum number of code points to write.
    </param>
    <returns>Either a Unicode code point (from 0-0xd7ff or from 0xe000 to 0x10ffff), or
      the value -1 indicating the end of the source.
    </returns>
  </doc>
  <doc name='M:PeterO.Cbor.ICharacterInput.ReadChar'>
    <summary>Reads a Unicode character from a data source.
    </summary>
    <returns>Either a Unicode code point (from 0-0xd7ff or from 0xe000 to 0x10ffff), or
      the value -1 indicating the end of the source.
    </returns>
  </doc>
  <doc name='T:PeterO.Cbor.JSONOptions'>
    <seealso cref='M:PeterO.Cbor.CBORObject.ToJSONString'/>
    <summary>Includes options to control how CBOR objects are converted to JSON.
    </summary>
  </doc>
  <doc name='M:PeterO.Cbor.JSONOptions.#ctor'>
    <summary>Initializes a new instance of the
      <see cref='JSONOptions'/>
       class with default options.
    </summary>
  </doc>
  <doc name='M:PeterO.Cbor.JSONOptions.#ctor(System.Boolean)'>
    <summary>Initializes a new instance of the
      <see cref='JSONOptions'/>
       class with the given value for the Base64Padding option.
    </summary>
    <param name='base64Padding'>Whether padding is included when writing data in base64url or traditional
      base64 format to JSON.
    </param>
  </doc>
  <doc name='M:PeterO.Cbor.JSONOptions.#ctor(System.Boolean,System.Boolean)'>
    <summary>Initializes a new instance of the
      <see cref='JSONOptions'/>
       class with the given values for the options.
    </summary>
    <param name='base64Padding'>Whether padding is included when writing data in base64url or traditional
      base64 format to JSON.
    </param>
    <param name='replaceSurrogates'>Whether surrogate code points not part of a surrogate pair (which consists
      of two consecutive
      <c>char</c> s forming one Unicode code point) are each replaced with a replacement
      character (U+FFFD). The default is false; an exception is thrown when such
      code points are encountered.
    </param>
  </doc>
  <doc name='P:PeterO.Cbor.JSONOptions.Base64Padding'>
    <summary>Gets a value indicating whether the Base64Padding property is true. This
      property has no effect; in previous versions, this property meant that
      padding was written out when writing base64url or traditional base64 to
      JSON.
    </summary>
    <value>A value indicating whether the Base64Padding property is true.
    </value>
  </doc>
  <doc name='F:PeterO.Cbor.JSONOptions.Default'>
    <summary>The default options for converting CBOR objects to JSON.
    </summary>
  </doc>
  <doc name='P:PeterO.Cbor.JSONOptions.ReplaceSurrogates'>
    <summary>Gets a value indicating whether surrogate code points not part of a
      surrogate pair (which consists of two consecutive
      <c>char</c> s forming one Unicode code point) are each replaced with a replacement
      character (U+FFFD). The default is false; an exception is thrown when such
      code points are encountered.
    </summary>
    <value>True, if surrogate code points not part of a surrogate pair are each
      replaced with a replacement character, or false if an exception is thrown
      when such code points are encountered.
    </value>
  </doc>
  <doc name='T:PeterO.Cbor.PODOptions'>
    <summary>Options for converting "plain old data" objects (better known as POCOs in
      .NET or POJOs in Java) to CBOR objects.
    </summary>
  </doc>
  <doc name='M:PeterO.Cbor.PODOptions.#ctor'>
    <summary>Initializes a new instance of the
      <see cref='PODOptions'/>
       class.
    </summary>
  </doc>
  <doc name='M:PeterO.Cbor.PODOptions.#ctor(System.Boolean,System.Boolean)'>
    <summary>Initializes a new instance of the
      <see cref='PODOptions'/>
       class.
    </summary>
    <param name='removeIsPrefix'>If set to
      <c>true</c> remove is prefix.
    </param>
    <param name='useCamelCase'>If set to
      <c>true</c> use camel case.
    </param>
  </doc>
  <doc name='F:PeterO.Cbor.PODOptions.Default'>
    <summary>The default settings for "plain old data" options.
    </summary>
  </doc>
  <doc name='P:PeterO.Cbor.PODOptions.RemoveIsPrefix'>
    <summary>Gets a value indicating whether the "Is" prefix in property names is
      removed before they are used as keys.
    </summary>
    <value><c>true</c> If the prefix is removed; otherwise, .
      <c>false</c> .
    </value>
  </doc>
  <doc name='P:PeterO.Cbor.PODOptions.UseCamelCase'>
    <summary><para>Gets a value indicating whether property names are converted to camel
        case before they are used as keys. This option changes the behavior of
        key name serialization as follows. If "useCamelCase" is
        <c>false</c> :
      </para>
      <list>
        <item>In the .NET version, all key names are capitalized, meaning the first
          letter in the name is converted to upper case if it's a basic
          lower-case letter ("a" to "z"). (For example, "Name" and "IsName" both
          remain unchanged.)
        </item>
        <item>In the Java version, for each eligible method name, the word "get" or
          "set" is removed from the name if the name starts with that word, then
          the name is capitalized. (For example, "getName" and "setName" both
          become "Name", and "isName" becomes "IsName".)
        </item>
      </list>
      <para>If "useCamelCase" is
        <c>true</c> :
      </para>
      <list>
        <item>In the .NET version, for each eligible property name, the word "Is" is
          removed from the name if the name starts with that word, then the name
          is converted to camel case, meaning the first letter in the name is
          converted to lower case if it's a basic upper-case letter ("A" to
          "Z"). (For example, "Name" and "IsName" both become "name".)
        </item>
        <item>In the Java version, for each eligible method name, the word "get",
          "set", or "is" is removed from the name if the name starts with that
          word, then the name is converted to camel case. (For example,
          "getName", "setName", and "isName" all become "name".)
        </item>
      </list>
      <para>In the description above, a name "starts with" a word if that word
        begins the name and is followed by a character other than a basic digit
        or lower-case letter, that is, other than "a" to "z" or "0" to "9".
      </para>
    </summary>
    <value><c>true</c> If the names are converted to camel case; otherwise,
      <c>false</c> . This property is
      <c>true</c> by default.
    </value>
  </doc>
  <doc name='T:PeterO.Cbor.StringRefs'>
    <summary>Implements CBOR string references, described at
      <c>http://cbor.schmorp.de/stringref</c> .
    </summary>
  </doc>
  <doc name='T:PeterO.Cbor.URIUtility'>
    <summary>Contains utility methods for processing Uniform Resource Identifiers
      (URIs) and Internationalized Resource Identifiers (IRIs) under RFC3986 and
      RFC3987, respectively. In the following documentation, URIs and IRIs
      include URI references and IRI references, for convenience.
      <para>There are five components to a URI: scheme, authority, path, query, and
        fragment identifier. The generic syntax to these components is defined
        in RFC3986 and extended in RFC3987. According to RFC3986, different URI
        schemes can further restrict the syntax of the authority, path, and
        query component (see also RFC 7320). However, the syntax of fragment
        identifiers depends on the media type (also known as MIME type) of the
        resource a URI references (see also RFC 3986 and RFC 7320). As of May
        18, 2019, only the following media types specify a syntax for fragment
        identifiers:
      </para>
      <list>
        <item>The following application/* media types: epub+zip, pdf, senml+cbor,
          senml+json, senml-exi, sensml+cbor, sensml+json, sensml-exi, smil,
          vnd.3gpp-v2x-local-service-information, vnd.3gpp.mcdata-signalling,
          vnd.collection.doc+json, vnd.hc+json, vnd.hyper+json,
          vnd.hyper-item+json, vnd.mason+json,
          vnd.microsoft.portable-executable, vnd.oma.bcast.sgdu,
          vnd.shootproof+json
        </item>
        <item>The following image/* media types: avci, avcs, heic, heic-sequence,
          heif, heif-sequence, hej2k, hsj2
        </item>
        <item>The XML media types: application/xml,
          application/xml-external-parsed-entity, text/xml,
          text/xml-external-parsed-entity, application/xml-dtd
        </item>
        <item>All media types with subtypes ending in "+xml" (see RFC 7303) use
          XPointer Framework syntax as fragment identifiers, except the
          following application/* media types: dicom+xml, senml+xml, sensml+xml,
          ttml+xml, xliff+xml, yang-data+xml
        </item>
        <item>font/collection
        </item>
        <item>multipart/x-mixed-replace
        </item>
        <item>text/plain
        </item>
        <item>text/csv
        </item>
        <item>text/html
        </item>
        <item>text/markdown
        </item>
        <item>text/vnd.a
        </item>
      </list>
    </summary>
  </doc>
  <doc name='M:PeterO.Cbor.URIUtility.EncodeStringForURI(System.String)'>
    <summary>Encodes characters other than "unreserved" characters for URIs.
    </summary>
    <param name='s'>A string to encode.
    </param>
    <returns>The encoded string.
    </returns>
    <exception cref='T:System.ArgumentNullException'>The parameter
      <paramref name='s'/>
       is null.
    </exception>
  </doc>
  <doc name='T:PeterO.Cbor.URIUtility.ParseMode'>
    <summary>Specifies whether certain characters are allowed when parsing IRIs and
      URIs.
    </summary>
  </doc>
  <doc name='F:PeterO.Cbor.URIUtility.ParseMode.IRILenient'>
    <summary>The rules only check for the appropriate delimiters when splitting the
      path, without checking if all the characters in each component are valid.
      Even with this mode, strings with unpaired surrogate code points are
      considered invalid.
    </summary>
  </doc>
  <doc name='F:PeterO.Cbor.URIUtility.ParseMode.IRIStrict'>
    <summary>The rules follow the syntax for parsing IRIs. In particular, many code
      points outside the Basic Latin range (U+0000 to U+007F) are allowed.
      Strings with unpaired surrogate code points are considered invalid.
    </summary>
  </doc>
  <doc name='F:PeterO.Cbor.URIUtility.ParseMode.IRISurrogateLenient'>
    <summary>The rules only check for the appropriate delimiters when splitting the
      path, without checking if all the characters in each component are valid.
      Unpaired surrogate code points are treated as though they were replacement
      characters instead for the purposes of these rules, so that strings with
      those code points are not considered invalid strings.
    </summary>
  </doc>
  <doc name='F:PeterO.Cbor.URIUtility.ParseMode.URILenient'>
    <summary>The rules only check for the appropriate delimiters when splitting the
      path, without checking if all the characters in each component are valid.
      Code points outside the Basic Latin range (U+0000 to U+007F) are not
      allowed.
    </summary>
  </doc>
  <doc name='F:PeterO.Cbor.URIUtility.ParseMode.URIStrict'>
    <summary>The rules follow the syntax for parsing IRIs, except that code points
      outside the Basic Latin range (U+0000 to U+007F) are not allowed.
    </summary>
  </doc>
  <doc name='M:PeterO.Cbor.URIUtility.PercentDecode(System.String)'>
    <summary>Decodes percent-encoding (of the form "%XX" where X is a hexadecimal
      digit) in the given string. Successive percent-encoded bytes are assumed
      to form characters in UTF-8.
    </summary>
    <param name='str'>A string that may contain percent encoding. May be null.
    </param>
    <returns>The string in which percent-encoding was decoded.
    </returns>
  </doc>
  <doc name='M:PeterO.Cbor.URIUtility.PercentDecode(System.String,System.Int32,System.Int32)'>
    <summary>Decodes percent-encoding (of the form "%XX" where X is a hexadecimal
      digit) in the given portion of a string. Successive percent-encoded bytes
      are assumed to form characters in UTF-8.
    </summary>
    <param name='str'>A string a portion of which may contain percent encoding. May be null.
    </param>
    <param name='index'>Zero-based index showing where the desired portion of
      <paramref name='str'/>
       begins.
    </param>
    <param name='endIndex'>Zero-based index showing where the desired portion of
      <paramref name='str'/>
       ends. The character before this index is the last character.
    </param>
    <returns>The portion of the given string in which percent-encoding was decoded.
      Returns null if
      <paramref name='str'/>
       is ull.
    </returns>
  </doc>
  <doc name='M:PeterO.Cbor.URIUtility.escapeURI(System.String,System.Int32)'>
    <summary>Escapes characters that can't appear in URIs or IRIs. The function is
      idempotent; that is, calling the function again on the result with the
      same mode doesn't change the result.
    </summary>
    <param name='s'>A string to escape.
    </param>
    <param name='mode'>The parameter
      <paramref name='mode'/>
       is a 32-bit signed integer.
    </param>
    <returns>A string possibly containing escaped characters, or null if s is null.
    </returns>
  </doc>
  <doc name='M:PeterO.Cbor.URIUtility.hasScheme(System.String)'>
    <summary>Determines whether the string is a valid IRI with a scheme component. This
      can be used to check for relative IRI references.
      <para>The following cases return true:
      </para>
      <code>xx-x:mm example:/ww</code> The following cases return false:
      <code>x@y:/z /x/y/z example.xyz</code> .
    </summary>
    <param name='refValue'>A string representing an IRI to check.
    </param>
    <returns><c>true</c> if the string is a valid IRI with a scheme component; otherwise,
      <c>false</c> .
    </returns>
  </doc>
  <doc name='M:PeterO.Cbor.URIUtility.hasSchemeForURI(System.String)'>
    <summary>Determines whether the string is a valid URI with a scheme component. This
      can be used to check for relative URI references. The following cases
      return true:
      <code>http://example/z xx-x:mm example:/ww</code> The following cases return false:
      <code>x@y:/z /x/y/z example.xyz</code> .
    </summary>
    <param name='refValue'>A string representing an IRI to check.
    </param>
    <returns><c>true</c> if the string is a valid URI with a scheme component; otherwise,
      <c>false</c> .
    </returns>
  </doc>
  <doc name='M:PeterO.Cbor.URIUtility.isValidCurieReference(System.String,System.Int32,System.Int32)'>
    <summary>Determines whether the substring is a valid CURIE reference under RDFA
      1.1. (The CURIE reference is the part after the colon.).
    </summary>
    <param name='s'>A string containing a CURIE reference. Can be null.
    </param>
    <param name='offset'>A zero-based index showing where the desired portion of "s" begins.
    </param>
    <param name='length'>The number of elements in the desired portion of "s" (but not more than
      "s" 's length).
    </param>
    <returns><c>true</c> if the substring is a valid CURIE reference under RDFA 1; otherwise,
      <c>false</c> . Returns false if
      <paramref name='s'/>
       is null.
    </returns>
    <exception cref='T:System.ArgumentException'>Either
      <paramref name='offset'/>
       or
      <paramref name='length'/>
       is less than 0 or greater than
      <paramref name='s'/>
       's length, or
      <paramref name='s'/>
       ' s length minus
      <paramref name='offset'/>
       is less than
      <paramref name='length'/>
       .
    </exception>
    <exception cref='T:System.ArgumentNullException'>The parameter
      <paramref name='s'/>
       is null.
    </exception>
  </doc>
  <doc name='M:PeterO.Cbor.URIUtility.relativeResolve(System.String,System.String)'>
    <summary>Resolves a URI or IRI relative to another URI or IRI.
    </summary>
    <param name='refValue'>A string representing a URI or IRI reference. Example:
      <c>dir/file.txt</c> .
    </param>
    <param name='baseURI'>A string representing an absolute URI reference. Example:
      <c>http://example.com/my/path/</c> .
    </param>
    <returns>The resolved IRI, or null if
      <paramref name='refValue'/>
       is null or is not a valid IRI. If
      <paramref name='baseURI'/>
       is null or is not a valid IRI, returns refValue. Example:
      <c>http://example.com/my/path/dir/file.txt</c> .
    </returns>
  </doc>
  <doc name='M:PeterO.Cbor.URIUtility.relativeResolve(System.String,System.String,PeterO.Cbor.URIUtility.ParseMode)'>
    <summary>Resolves a URI or IRI relative to another URI or IRI.
    </summary>
    <param name='refValue'>A string representing a URI or IRI reference. Example:
      <c>dir/file.txt</c> . Can be null.
    </param>
    <param name='baseURI'>A string representing an absolute URI reference. Example:
      <c>http://example.com/my/path/</c> .
    </param>
    <param name='parseMode'>Parse mode that specifies whether certain characters are allowed when
      parsing IRIs and URIs.
    </param>
    <returns>The resolved IRI, or null if
      <paramref name='refValue'/>
       is null or is not a valid IRI. If
      <paramref name='baseURI'/>
       is null or is not a valid IRI, returns refValue.
    </returns>
  </doc>
  <doc name='M:PeterO.Cbor.URIUtility.splitIRI(System.String)'>
    <summary>Parses an Internationalized Resource Identifier (IRI) reference under
      RFC3987. If the IRI reference is syntactically valid, splits the string
      into its components and returns an array containing the indices into the
      components.
    </summary>
    <param name='s'>A string that contains an IRI. Can be null.
    </param>
    <returns>If the string is a valid IRI reference, returns an array of 10 integers.
      Each of the five pairs corresponds to the start and end index of the IRI's
      scheme, authority, path, query, or fragment identifier, respectively. The
      scheme, authority, query, and fragment identifier, if present, will each
      be given without the ending colon, the starting "//", the starting "?",
      and the starting "#", respectively. If a component is absent, both indices
      in that pair will be -1. If the string is null or is not a valid IRI,
      returns null.
    </returns>
  </doc>
  <doc name='M:PeterO.Cbor.URIUtility.splitIRI(System.String,PeterO.Cbor.URIUtility.ParseMode)'>
    <summary>Parses an Internationalized Resource Identifier (IRI) reference under
      RFC3987. If the IRI is syntactically valid, splits the string into its
      components and returns an array containing the indices into the
      components.
    </summary>
    <param name='s'>A string representing an IRI. Can be null.
    </param>
    <param name='parseMode'>The parameter
      <paramref name='parseMode'/>
       is a ParseMode object.
    </param>
    <returns>If the string is a valid IRI reference, returns an array of 10 integers.
      Each of the five pairs corresponds to the start and end index of the IRI's
      scheme, authority, path, query, or fragment identifier, respectively. The
      scheme, authority, query, and fragment identifier, if present, will each
      be given without the ending colon, the starting "//", the starting "?",
      and the starting "#", respectively. If a component is absent, both indices
      in that pair will be -1. If the string is null or is not a valid IRI,
      returns null.
    </returns>
  </doc>
  <doc name='M:PeterO.Cbor.URIUtility.splitIRI(System.String,System.Int32,System.Int32,PeterO.Cbor.URIUtility.ParseMode)'>
    <summary>Parses a substring that represents an Internationalized Resource
      Identifier (IRI) under RFC3987. If the IRI is syntactically valid, splits
      the string into its components and returns an array containing the indices
      into the components.
    </summary>
    <param name='s'>A string that contains an IRI. Can be null.
    </param>
    <param name='offset'>A zero-based index showing where the desired portion of "s" begins.
    </param>
    <param name='length'>The length of the desired portion of "s" (but not more than "s" 's
      length).
    </param>
    <param name='parseMode'>Parse mode that specifies whether certain characters are allowed when
      parsing IRIs and URIs.
    </param>
    <returns>If the string is a valid IRI, returns an array of 10 integers. Each of the
      five pairs corresponds to the start and end index of the IRI's scheme,
      authority, path, query, or fragment component, respectively. The scheme,
      authority, query, and fragment components, if present, will each be given
      without the ending colon, the starting "//", the starting "?", and the
      starting "#", respectively. If a component is absent, both indices in that
      pair will be -1 (an index won't be less than 0 in any other case). If the
      string is null or is not a valid IRI, returns null.
    </returns>
    <exception cref='T:System.ArgumentException'>Either
      <paramref name='offset'/>
       or
      <paramref name='length'/>
       is less than 0 or greater than
      <paramref name='s'/>
       's length, or
      <paramref name='s'/>
       ' s length minus
      <paramref name='offset'/>
       is less than
      <paramref name='length'/>
       .
    </exception>
    <exception cref='T:System.ArgumentNullException'>The parameter
      <paramref name='s'/>
       is null.
    </exception>
  </doc>
  <doc name='T:PeterO.DataUtilities'>
    <summary>Contains methods useful for reading and writing strings. It is designed to
      have no dependencies other than the basic runtime class library.
      <para>Many of these methods work with text encoded in UTF-8, an encoding form
        of the Unicode Standard which uses one byte to encode the most basic
        characters and two to four bytes to encode other characters. For
        example, the
        <c>GetUtf8</c> method converts a text string to an array of bytes in UTF-8.
      </para>
      <para>In C# and Java, text strings are represented as sequences of 16-bit
        values called
        <c>char</c> s. These sequences are well-formed under UTF-16, a 16-bit encoding form
        of Unicode, except if they contain unpaired surrogate code points. (A
        surrogate code point is used to encode supplementary characters, those
        with code points U+10000 or higher, in UTF-16. A surrogate pair is a
        high surrogate [U+D800 to U+DBFF] followed by a low surrogate [U+DC00 to
        U+DFFF]. An unpaired surrogate code point is a surrogate not appearing
        in a surrogate pair.) Many of the methods in this class allow setting
        the behavior to follow when unpaired surrogate code points are found in
        text strings, such as throwing an error or treating the unpaired
        surrogate as a replacement character (U+FFFD).
      </para>
    </summary>
  </doc>
  <doc name='M:PeterO.DataUtilities.CodePointAt(System.String,System.Int32)'>
    <summary>Gets the Unicode code point at the given index of the string.
    </summary>
    <param name='str'>The parameter
      <paramref name='str'/>
       is a text string.
    </param>
    <param name='index'>Index of the current position into the string.
    </param>
    <returns>The Unicode code point at the given position. Returns -1 if
      <paramref name='index'/>
       is less than 0, or is the string's length or greater. Returns the
      replacement character (U+FFFD) if the current character is an unpaired
      surrogate code point. If the return value is 65536 (0x10000) or greater,
      the code point takes up two UTF-16 code units.
    </returns>
    <exception cref='T:System.ArgumentNullException'>The parameter
      <paramref name='str'/>
       is null.
    </exception>
    <example><para>The following example shows how to iterate a text string code point by
        code point.
      </para>
      <code>for(var i=0;i&lt;str.Length;i++) { int codePoint =
        DataUtilities.CodePointAt(str,i);
        Console.WriteLine("codePoint:"+codePoint); if(codePoint &gt;= 0x10000) {
        i++; /* Supplementary code point */ } }</code> .
    </example>
  </doc>
  <doc name='M:PeterO.DataUtilities.CodePointAt(System.String,System.Int32,System.Int32)'>
    <summary>Gets the Unicode code point at the given index of the string.
    </summary>
    <param name='str'>The parameter
      <paramref name='str'/>
       is a text string.
    </param>
    <param name='index'>Index of the current position into the string.
    </param>
    <param name='surrogateBehavior'>Specifies what kind of value to return if the previous character is an
      unpaired surrogate code point: if 0, return the replacement character
      (U+FFFD); if 1, return the value of the surrogate code point; if neither 0
      nor 1, return -1.
    </param>
    <returns>The Unicode code point at the current position. Returns -1 if
      <paramref name='index'/>
       is less than 0, or is the string's length or greater. Returns a value as
      specified under
      <paramref name='surrogateBehavior'/>
       if the previous character is an unpaired surrogate code point. If the
      return value is 65536 (0x10000) or greater, the code point takes up two
      UTF-16 code units.
    </returns>
    <exception cref='T:System.ArgumentNullException'>The parameter
      <paramref name='str'/>
       is null.
    </exception>
    <example><para>The following example shows how to iterate a text string code point by
        code point, terminating the loop when an unpaired surrogate is found.
      </para>
      <code>for(var i=0;i&lt;str.Length;i++) { int codePoint =
        DataUtilities.CodePointAt(str, i, 2); if(codePoint &lt; 0) { break; /*
        Unpaired surrogate */ } Console.WriteLine("codePoint:"+codePoint);
        if(codePoint &gt;= 0x10000) { i++; /* Supplementary code point */ } }</code> .
    </example>
  </doc>
  <doc name='M:PeterO.DataUtilities.CodePointBefore(System.String,System.Int32)'>
    <summary>Gets the Unicode code point just before the given index of the string.
    </summary>
    <param name='str'>The parameter
      <paramref name='str'/>
       is a text string.
    </param>
    <param name='index'>Index of the current position into the string.
    </param>
    <returns>The Unicode code point at the previous position. Returns -1 if
      <paramref name='index'/>
       is 0 or less, or is greater than the string's length. Returns the
      replacement character (U+FFFD) if the previous character is an unpaired
      surrogate code point. If the return value is 65536 (0x10000) or greater,
      the code point takes up two UTF-16 code units.
    </returns>
    <exception cref='T:System.ArgumentNullException'>The parameter
      <paramref name='str'/>
       is null.
    </exception>
  </doc>
  <doc name='M:PeterO.DataUtilities.CodePointBefore(System.String,System.Int32,System.Int32)'>
    <summary>Gets the Unicode code point just before the given index of the string.
    </summary>
    <param name='str'>The parameter
      <paramref name='str'/>
       is a text string.
    </param>
    <param name='index'>Index of the current position into the string.
    </param>
    <param name='surrogateBehavior'>Specifies what kind of value to return if the previous character is an
      unpaired surrogate code point: if 0, return the replacement character
      (U+FFFD); if 1, return the value of the surrogate code point; if neither 0
      nor 1, return -1.
    </param>
    <returns>The Unicode code point at the previous position. Returns -1 if
      <paramref name='index'/>
       is 0 or less, or is greater than the string's length. Returns a value as
      specified under
      <paramref name='surrogateBehavior'/>
       if the previous character is an unpaired surrogate code point. If the
      return value is 65536 (0x10000) or greater, the code point takes up two
      UTF-16 code units.
    </returns>
    <exception cref='T:System.ArgumentNullException'>The parameter
      <paramref name='str'/>
       is null.
    </exception>
  </doc>
  <doc name='M:PeterO.DataUtilities.CodePointCompare(System.String,System.String)'>
    <summary>Compares two strings in Unicode code point order. Unpaired surrogate code
      points are treated as individual code points.
    </summary>
    <param name='strA'>The first string. Can be null.
    </param>
    <param name='strB'>The second string. Can be null.
    </param>
    <returns>A value indicating which string is " less" or " greater" . 0: Both strings
      are equal or null. Less than 0: a is null and b isn't; or the first code
      point that's different is less in A than in B; or b starts with a and is
      longer than a. Greater than 0: b is null and a isn't; or the first code
      point that's different is greater in A than in B; or a starts with b and
      is longer than b.
    </returns>
  </doc>
  <doc name='M:PeterO.DataUtilities.CodePointLength(System.String)'>
    <summary>Finds the number of Unicode code points in the given text string. Unpaired
      surrogate code points increase this number by 1. This is not necessarily
      the length of the string in "char" s.
    </summary>
    <param name='str'>The parameter
      <paramref name='str'/>
       is a text string.
    </param>
    <returns>The number of Unicode code points in the given string.
    </returns>
    <exception cref='T:System.ArgumentNullException'>The parameter
      <paramref name='str'/>
       is null.
    </exception>
  </doc>
  <doc name='M:PeterO.DataUtilities.GetUtf8Bytes(System.String,System.Boolean)'>
    <summary><para>Encodes a string in UTF-8 as a byte array. This method does not insert a
        byte-order mark (U+FEFF) at the beginning of the encoded byte array.
      </para>
      <para>REMARK: It is not recommended to use
        <c>Encoding.UTF8.GetBytes</c> in .NET, or the
        <c>getBytes()</c> method in Java to do this. For instance,
        <c>getBytes()</c> encodes text strings in a default (so not fixed) character encoding,
        which can be undesirable.
      </para>
    </summary>
    <param name='str'>The parameter
      <paramref name='str'/>
       is a text string.
    </param>
    <param name='replace'>If true, replaces unpaired surrogate code points with the replacement
      character (U+FFFD). If false, stops processing when an unpaired surrogate
      code point is seen.
    </param>
    <returns>The string encoded in UTF-8.
    </returns>
    <exception cref='T:System.ArgumentNullException'>The parameter
      <paramref name='str'/>
       is null.
    </exception>
    <exception cref='T:System.ArgumentException'>The string contains an unpaired surrogate code point and
      <paramref name='replace'/>
       is false, or an internal error occurred.
    </exception>
  </doc>
  <doc name='M:PeterO.DataUtilities.GetUtf8Bytes(System.String,System.Boolean,System.Boolean)'>
    <summary><para>Encodes a string in UTF-8 as a byte array. This method does not insert a
        byte-order mark (U+FEFF) at the beginning of the encoded byte array.
      </para>
      <para>REMARK: It is not recommended to use
        <c>Encoding.UTF8.GetBytes</c> in .NET, or the
        <c>getBytes()</c> method in Java to do this. For instance,
        <c>getBytes()</c> encodes text strings in a default (so not fixed) character encoding,
        which can be undesirable.
      </para>
    </summary>
    <param name='str'>The parameter
      <paramref name='str'/>
       is a text string.
    </param>
    <param name='replace'>If true, replaces unpaired surrogate code points with the replacement
      character (U+FFFD). If false, stops processing when an unpaired surrogate
      code point is seen.
    </param>
    <param name='lenientLineBreaks'>If true, replaces carriage return (CR) not followed by line feed (LF) and
      LF not preceded by CR with CR-LF pairs.
    </param>
    <returns>The string encoded in UTF-8.
    </returns>
    <exception cref='T:System.ArgumentNullException'>The parameter
      <paramref name='str'/>
       is null.
    </exception>
    <exception cref='T:System.ArgumentException'>The string contains an unpaired surrogate code point and
      <paramref name='replace'/>
       is false, or an internal error occurred.
    </exception>
  </doc>
  <doc name='M:PeterO.DataUtilities.GetUtf8Length(System.String,System.Boolean)'>
    <summary>Calculates the number of bytes needed to encode a string in UTF-8.
    </summary>
    <param name='str'>The parameter
      <paramref name='str'/>
       is a text string.
    </param>
    <param name='replace'>If true, treats unpaired surrogate code points as having 3 UTF-8 bytes
      (the UTF-8 length of the replacement character U+FFFD).
    </param>
    <returns>The number of bytes needed to encode the given string in UTF-8, or -1 if
      the string contains an unpaired surrogate code point and
      <paramref name='replace'/>
       is false.
    </returns>
    <exception cref='T:System.ArgumentNullException'>The parameter
      <paramref name='str'/>
       is null.
    </exception>
  </doc>
  <doc name='M:PeterO.DataUtilities.GetUtf8String(System.Byte[],System.Boolean)'>
    <summary>Generates a text string from a UTF-8 byte array.
    </summary>
    <param name='bytes'>A byte array containing text encoded in UTF-8.
    </param>
    <param name='replace'>If true, replaces invalid encoding with the replacement character
      (U+FFFD). If false, stops processing when invalid UTF-8 is seen.
    </param>
    <returns>A string represented by the UTF-8 byte array.
    </returns>
    <exception cref='T:System.ArgumentNullException'>The parameter
      <paramref name='bytes'/>
       is null.
    </exception>
    <exception cref='T:System.ArgumentException'>The string is not valid UTF-8 and
      <paramref name='replace'/>
       is false.
    </exception>
  </doc>
  <doc name='M:PeterO.DataUtilities.GetUtf8String(System.Byte[],System.Int32,System.Int32,System.Boolean)'>
    <summary>Generates a text string from a portion of a UTF-8 byte array.
    </summary>
    <param name='bytes'>A byte array containing text encoded in UTF-8.
    </param>
    <param name='offset'>Offset into the byte array to start reading.
    </param>
    <param name='bytesCount'>Length, in bytes, of the UTF-8 text string.
    </param>
    <param name='replace'>If true, replaces invalid encoding with the replacement character
      (U+FFFD). If false, stops processing when invalid UTF-8 is seen.
    </param>
    <returns>A string represented by the UTF-8 byte array.
    </returns>
    <exception cref='T:System.ArgumentNullException'>The parameter
      <paramref name='bytes'/>
       is null.
    </exception>
    <exception cref='T:System.ArgumentException'>The portion of the byte array is not valid UTF-8 and
      <paramref name='replace'/>
       is false.
    </exception>
    <exception cref='T:System.ArgumentException'>The parameter
      <paramref name='offset'/>
       is less than 0,
      <paramref name='bytesCount'/>
       is less than 0, or offset plus bytesCount is greater than the length of
      "data" .
    </exception>
  </doc>
  <doc name='M:PeterO.DataUtilities.ReadUtf8(System.IO.Stream,System.Int32,System.Text.StringBuilder,System.Boolean)'>
    <summary>Reads a string in UTF-8 encoding from a data stream.
    </summary>
    <param name='stream'>A readable data stream.
    </param>
    <param name='bytesCount'>The length, in bytes, of the string. If this is less than 0, this function
      will read until the end of the stream.
    </param>
    <param name='builder'>A string builder object where the resulting string will be stored.
    </param>
    <param name='replace'>If true, replaces invalid encoding with the replacement character
      (U+FFFD). If false, stops processing when an unpaired surrogate code point
      is seen.
    </param>
    <returns>0 if the entire string was read without errors, -1 if the string is not
      valid UTF-8 and
      <paramref name='replace'/>
       is false, or -2 if the end of the stream was reached before the last
      character was read completely (which is only the case if
      <paramref name='bytesCount'/>
       is 0 or greater).
    </returns>
    <exception cref='T:System.IO.IOException'>An I/O error occurred.
    </exception>
    <exception cref='T:System.ArgumentNullException'>The parameter
      <paramref name='stream'/>
       is null or
      <paramref name='builder'/>
       is null.
    </exception>
  </doc>
  <doc name='M:PeterO.DataUtilities.ReadUtf8FromBytes(System.Byte[],System.Int32,System.Int32,System.Text.StringBuilder,System.Boolean)'>
    <summary>Reads a string in UTF-8 encoding from a byte array.
    </summary>
    <param name='data'>A byte array containing a UTF-8 text string.
    </param>
    <param name='offset'>Offset into the byte array to start reading.
    </param>
    <param name='bytesCount'>Length, in bytes, of the UTF-8 text string.
    </param>
    <param name='builder'>A string builder object where the resulting string will be stored.
    </param>
    <param name='replace'>If true, replaces invalid encoding with the replacement character
      (U+FFFD). If false, stops processing when invalid UTF-8 is seen.
    </param>
    <returns>0 if the entire string was read without errors, or -1 if the string is not
      valid UTF-8 and
      <paramref name='replace'/>
       is false.
    </returns>
    <exception cref='T:System.ArgumentNullException'>The parameter
      <paramref name='data'/>
       is null or
      <paramref name='builder'/>
       is null.
    </exception>
    <exception cref='T:System.ArgumentException'>The parameter
      <paramref name='offset'/>
       is less than 0,
      <paramref name='bytesCount'/>
       is less than 0, or offset plus bytesCount is greater than the length of
      <paramref name='data'/>
       .
    </exception>
  </doc>
  <doc name='M:PeterO.DataUtilities.ReadUtf8ToString(System.IO.Stream)'>
    <summary>Reads a string in UTF-8 encoding from a data stream in full and returns
      that string. Replaces invalid encoding with the replacement character
      (U+FFFD).
    </summary>
    <param name='stream'>A readable data stream.
    </param>
    <returns>The string read.
    </returns>
    <exception cref='T:System.IO.IOException'>An I/O error occurred.
    </exception>
    <exception cref='T:System.ArgumentNullException'>The parameter
      <paramref name='stream'/>
       is null.
    </exception>
  </doc>
  <doc name='M:PeterO.DataUtilities.ReadUtf8ToString(System.IO.Stream,System.Int32,System.Boolean)'>
    <summary>Reads a string in UTF-8 encoding from a data stream and returns that
      string.
    </summary>
    <param name='stream'>A readable data stream.
    </param>
    <param name='bytesCount'>The length, in bytes, of the string. If this is less than 0, this function
      will read until the end of the stream.
    </param>
    <param name='replace'>If true, replaces invalid encoding with the replacement character
      (U+FFFD). If false, throws an error if an unpaired surrogate code point is
      seen.
    </param>
    <returns>The string read.
    </returns>
    <exception cref='T:System.IO.IOException'>An I/O error occurred; or, the string is not valid UTF-8 and
      <paramref name='replace'/>
       is false.
    </exception>
    <exception cref='T:System.ArgumentNullException'>The parameter
      <paramref name='stream'/>
       is null.
    </exception>
  </doc>
  <doc name='M:PeterO.DataUtilities.ToLowerCaseAscii(System.String)'>
    <summary>Returns a string with the basic upper-case letters A to Z (U+0041 to
      U+005A) converted to lower-case. Other characters remain unchanged.
    </summary>
    <param name='str'>The parameter
      <paramref name='str'/>
       is a text string.
    </param>
    <returns>The converted string, or null if
      <paramref name='str'/>
       is null.
    </returns>
  </doc>
  <doc name='M:PeterO.DataUtilities.ToUpperCaseAscii(System.String)'>
    <summary>Returns a string with the basic lower-case letters A to Z (U+0061 to
      U+007A) converted to upper-case. Other characters remain unchanged.
    </summary>
    <param name='str'>The parameter
      <paramref name='str'/>
       is a text string.
    </param>
    <returns>The converted string, or null if
      <paramref name='str'/>
       is null.
    </returns>
  </doc>
  <doc name='M:PeterO.DataUtilities.WriteUtf8(System.String,System.IO.Stream,System.Boolean)'>
    <summary>Writes a string in UTF-8 encoding to a data stream.
    </summary>
    <param name='str'>A string to write.
    </param>
    <param name='stream'>A writable data stream.
    </param>
    <param name='replace'>If true, replaces unpaired surrogate code points with the replacement
      character (U+FFFD). If false, stops processing when an unpaired surrogate
      code point is seen.
    </param>
    <returns>0 if the entire string was written; or -1 if the string contains an
      unpaired surrogate code point and
      <paramref name='replace'/>
       is false.
    </returns>
    <exception cref='T:System.ArgumentNullException'>The parameter
      <paramref name='str'/>
       is null or
      <paramref name='stream'/>
       is null.
    </exception>
    <exception cref='T:System.IO.IOException'>An I/O error occurred.
    </exception>
  </doc>
  <doc name='M:PeterO.DataUtilities.WriteUtf8(System.String,System.Int32,System.Int32,System.IO.Stream,System.Boolean)'>
    <summary>Writes a portion of a string in UTF-8 encoding to a data stream.
    </summary>
    <param name='str'>A string to write.
    </param>
    <param name='offset'>The zero-based index where the string portion to write begins.
    </param>
    <param name='length'>The length of the string portion to write.
    </param>
    <param name='stream'>A writable data stream.
    </param>
    <param name='replace'>If true, replaces unpaired surrogate code points with the replacement
      character (U+FFFD). If false, stops processing when an unpaired surrogate
      code point is seen.
    </param>
    <returns>0 if the entire string portion was written; or -1 if the string portion
      contains an unpaired surrogate code point and
      <paramref name='replace'/>
       is false.
    </returns>
    <exception cref='T:System.ArgumentNullException'>The parameter
      <paramref name='str'/>
       is null or
      <paramref name='stream'/>
       is null.
    </exception>
    <exception cref='T:System.ArgumentException'>The parameter
      <paramref name='offset'/>
       is less than 0,
      <paramref name='length'/>
       is less than 0, or
      <paramref name='offset'/>
       plus
      <paramref name='length'/>
       is greater than the string's length.
    </exception>
    <exception cref='T:System.IO.IOException'>An I/O error occurred.
    </exception>
  </doc>
  <doc name='M:PeterO.DataUtilities.WriteUtf8(System.String,System.Int32,System.Int32,System.IO.Stream,System.Boolean,System.Boolean)'>
    <summary>Writes a portion of a string in UTF-8 encoding to a data stream.
    </summary>
    <param name='str'>A string to write.
    </param>
    <param name='offset'>The zero-based index where the string portion to write begins.
    </param>
    <param name='length'>The length of the string portion to write.
    </param>
    <param name='stream'>A writable data stream.
    </param>
    <param name='replace'>If true, replaces unpaired surrogate code points with the replacement
      character (U+FFFD). If false, stops processing when an unpaired surrogate
      code point is seen.
    </param>
    <param name='lenientLineBreaks'>If true, replaces carriage return (CR) not followed by line feed (LF) and
      LF not preceded by CR with CR-LF pairs.
    </param>
    <returns>0 if the entire string portion was written; or -1 if the string portion
      contains an unpaired surrogate code point and
      <paramref name='replace'/>
       is false.
    </returns>
    <exception cref='T:System.ArgumentNullException'>The parameter
      <paramref name='str'/>
       is null or
      <paramref name='stream'/>
       is null.
    </exception>
    <exception cref='T:System.ArgumentException'>The parameter
      <paramref name='offset'/>
       is less than 0,
      <paramref name='length'/>
       is less than 0, or
      <paramref name='offset'/>
       plus
      <paramref name='length'/>
       is greater than the string's length.
    </exception>
    <exception cref='T:System.IO.IOException'>An I/O error occurred.
    </exception>
  </doc>
</docs>
